<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quarantine Perennial Football League</title>
    <link rel="icon" type="image/png" href="images/league_logo.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=JetBrains+Mono:wght@400;600&family=Outfit:wght@300;400;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-deep: #0a0a0f;
            --bg-card: #12121a;
            --bg-hover: #1a1a25;
            --accent-primary: #4488ff;
            --accent-secondary: #dd2222;
            --accent-tertiary: #6699ff;
            --text-primary: #ffffff;
            --text-secondary: #8888aa;
            --text-muted: #555566;
            --border: #2a2a3a;
            --win: #00ff88;
            --loss: #ff3366;
            --tie: #ffaa00;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Outfit', sans-serif;
            background: var(--bg-deep);
            color: var(--text-primary);
            min-height: 100vh;
            background-image: 
                radial-gradient(ellipse at 20% 20%, rgba(68, 136, 255, 0.05) 0%, transparent 50%),
                radial-gradient(ellipse at 80% 80%, rgba(102, 153, 255, 0.05) 0%, transparent 50%);
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
        }

        header {
            text-align: center;
            margin-bottom: 3rem;
            padding: 2rem 0;
            position: relative;
        }

        header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 2px;
            background: linear-gradient(90deg, transparent, var(--accent-primary), transparent);
        }

        .league-logo {
            display: block;
            margin: 0 auto 1rem auto;
            width: 120px;
            height: auto;
            filter: drop-shadow(0 0 20px rgba(68, 136, 255, 0.3));
        }

        .logo {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 2.5rem;
            letter-spacing: 0.1em;
            color: var(--accent-primary);
            text-align: center;
            text-shadow: 0 0 60px rgba(68, 136, 255, 0.3);
        }

        .season-selector {
            display: inline-block;
            position: relative;
            margin-top: 0.5rem;
        }

        .season-badge {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.25rem 1rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            color: var(--text-secondary);
            border: 1px solid var(--border);
            border-radius: 2rem;
            background: var(--bg-card);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .season-badge:hover {
            border-color: var(--accent-primary);
            color: var(--text-primary);
        }

        .season-badge::after {
            content: 'â–¼';
            font-size: 0.6rem;
            opacity: 0.6;
        }

        .season-dropdown {
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-top: 0.5rem;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            overflow: hidden;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s ease;
            z-index: 1000;
            min-width: 140px;
        }

        .season-selector.open .season-dropdown {
            opacity: 1;
            visibility: visible;
        }

        .season-option {
            display: block;
            width: 100%;
            padding: 0.5rem 1rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            color: var(--text-secondary);
            background: transparent;
            border: none;
            cursor: pointer;
            text-align: center;
            transition: all 0.15s ease;
        }

        .season-option:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
        }

        .season-option.active {
            background: var(--accent-primary);
            color: white;
        }

        .updated {
            margin-top: 1rem;
            font-size: 0.8rem;
            color: var(--text-muted);
            font-family: 'JetBrains Mono', monospace;
        }

        .live-indicator {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.25rem 0.75rem;
            background: rgba(221, 34, 34, 0.1);
            border: 1px solid var(--accent-secondary);
            border-radius: 2rem;
            font-size: 0.75rem;
            color: var(--accent-secondary);
            margin-left: 1rem;
        }

        .live-dot {
            width: 6px;
            height: 6px;
            background: var(--accent-secondary);
            border-radius: 50%;
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.2); }
        }

        nav {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-bottom: 2rem;
            flex-wrap: wrap;
        }

        .nav-btn {
            padding: 0.5rem 1.5rem;
            font-family: 'Outfit', sans-serif;
            font-weight: 600;
            font-size: 0.9rem;
            background: var(--bg-card);
            border: 1px solid var(--border);
            color: var(--text-secondary);
            border-radius: 0.5rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .nav-btn:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
            border-color: var(--accent-primary);
        }

        .nav-btn.active {
            background: linear-gradient(135deg, rgba(68, 136, 255, 0.2), rgba(102, 153, 255, 0.2));
            border-color: var(--accent-primary);
            color: var(--accent-primary);
        }

        .week-selector {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .week-btn {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            background: var(--bg-card);
            border: 1px solid var(--border);
            color: var(--text-secondary);
            border-radius: 0.5rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .week-btn:hover {
            background: var(--bg-hover);
            border-color: var(--accent-tertiary);
            color: var(--text-primary);
        }

        .week-btn.active {
            background: var(--accent-tertiary);
            border-color: var(--accent-tertiary);
            color: var(--bg-deep);
            font-weight: 600;
        }

        .week-btn.playoff {
            border-color: rgba(255, 215, 0, 0.4);
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.1), transparent);
        }

        .week-btn.playoff:hover {
            border-color: #ffd700;
            background: rgba(255, 215, 0, 0.2);
        }

        .week-btn.playoff.active {
            background: linear-gradient(135deg, #ffd700, #ff8c00);
            border-color: #ffd700;
            color: var(--bg-deep);
        }

        .week-label {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.5rem;
            letter-spacing: 0.1em;
            color: var(--text-secondary);
        }

        .matchups {
            display: grid;
            gap: 1.5rem;
        }

        .matchup-card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 1rem;
            overflow: hidden;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .matchup-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }

        .matchup-card.pending {
            opacity: 0.8;
        }

        .matchup-card.pending .vs-text {
            color: var(--text-muted);
            font-size: 0.9rem;
        }

        .matchup-card.pending.playoff {
            opacity: 1;
            border-color: rgba(255, 215, 0, 0.3);
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.05), transparent);
        }

        /* Playoff bracket styling - gold borders */
        .matchup-card.bracket-playoffs,
        .matchup-card.bracket-championship {
            border: 2px solid rgba(255, 215, 0, 0.5);
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.15);
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.08), transparent);
        }

        .matchup-card.bracket-playoffs:hover,
        .matchup-card.bracket-championship:hover {
            border-color: rgba(255, 215, 0, 0.7);
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.25);
        }

        /* Consolation Cup (3rd place game) styling - silver borders */
        .matchup-card.bracket-consolation_cup {
            border: 2px solid rgba(192, 192, 192, 0.6);
            box-shadow: 0 0 15px rgba(192, 192, 192, 0.2);
            background: linear-gradient(135deg, rgba(192, 192, 192, 0.1), transparent);
        }

        .matchup-card.bracket-consolation_cup:hover {
            border-color: rgba(220, 220, 220, 0.8);
            box-shadow: 0 0 25px rgba(192, 192, 192, 0.3);
        }

        /* Toilet bowl / Sewer series styling - brown borders */
        .matchup-card.bracket-toilet_bowl,
        .matchup-card.bracket-sewer_series {
            border: 2px solid rgba(139, 90, 43, 0.5);
            box-shadow: 0 0 15px rgba(139, 90, 43, 0.15);
            background: linear-gradient(135deg, rgba(139, 90, 43, 0.08), transparent);
        }

        .matchup-card.bracket-toilet_bowl:hover,
        .matchup-card.bracket-sewer_series:hover {
            border-color: rgba(139, 90, 43, 0.7);
            box-shadow: 0 0 25px rgba(139, 90, 43, 0.25);
        }

        /* Jamboree styling - purple borders */
        .matchup-card.bracket-jamboree,
        .jamboree-scoreboard {
            border: 2px solid rgba(153, 50, 204, 0.5);
            box-shadow: 0 0 15px rgba(153, 50, 204, 0.15);
            background: linear-gradient(135deg, rgba(153, 50, 204, 0.08), transparent);
        }

        .matchup-card.bracket-jamboree:hover {
            border-color: rgba(153, 50, 204, 0.7);
            box-shadow: 0 0 25px rgba(153, 50, 204, 0.25);
        }

        .jamboree-scoreboard {
            padding: 1.5rem;
            margin: 1rem 0;
            border-radius: 12px;
        }

        .jamboree-title {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.5rem;
            color: #BA55D3;
            margin-bottom: 1rem;
            text-align: center;
        }

        .jamboree-table {
            width: 100%;
            border-collapse: collapse;
        }

        .jamboree-table th,
        .jamboree-table td {
            padding: 0.75rem;
            text-align: left;
            border-bottom: 1px solid var(--border);
        }

        .jamboree-table th {
            color: var(--text-muted);
            font-size: 0.85rem;
            text-transform: uppercase;
        }

        .jamboree-table td.total {
            font-weight: bold;
            color: #BA55D3;
        }

        .jamboree-place {
            width: 40px;
            text-align: center;
        }

        .jamboree-place.first {
            color: gold;
        }

        .playoff-bracket-header.jamboree {
            background: linear-gradient(135deg, rgba(153, 50, 204, 0.2), rgba(153, 50, 204, 0.1));
            color: #BA55D3;
        }

        .matchup-seed {
            font-size: 0.75rem;
            color: var(--text-muted);
            font-family: 'JetBrains Mono', monospace;
            margin: 0 0.5rem;
        }

        .playoff-bracket-header {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.2rem;
            letter-spacing: 0.1em;
            padding: 1rem 0 0.5rem;
            margin-top: 1rem;
            border-top: 1px solid var(--border);
        }

        .playoff-bracket-header:first-child {
            margin-top: 0;
            border-top: none;
            padding-top: 0;
        }

        .playoff-bracket-header.playoffs {
            color: #ffd700;
        }

        .playoff-bracket-header.championship {
            color: #ffd700;
        }

        .playoff-bracket-header.consolation_cup {
            color: #C0C0C0;
            background: linear-gradient(135deg, rgba(192, 192, 192, 0.15), rgba(192, 192, 192, 0.05));
        }

        .playoff-bracket-header.mid_bowl {
            color: #6b8e23;
        }

        .playoff-bracket-header.sewer_series {
            color: #708090;
        }

        .playoff-bracket-header.toilet_bowl {
            color: #a87c4f;
        }

        .playoff-round-badge {
            background: linear-gradient(135deg, #ffd700, #ff8c00);
            color: var(--bg-deep);
            padding: 0.25rem 0.75rem;
            border-radius: 0.25rem;
            font-style: normal;
            font-weight: 600;
            font-size: 0.9rem;
            margin-right: 0.5rem;
        }

        .no-scores-message {
            text-align: center;
            padding: 1.5rem;
            color: var(--text-secondary);
            font-style: italic;
            margin-bottom: 1rem;
        }

        .no-scores-message.playoffs {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.1), transparent);
            border-radius: 0.5rem;
            border: 1px solid rgba(255, 215, 0, 0.2);
        }

        .matchup-header {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            align-items: center;
            padding: 1.5rem;
            gap: 1rem;
        }

        .team {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .team.right {
            text-align: right;
        }

        .team-name {
            font-weight: 600;
            font-size: 1.1rem;
            color: var(--text-primary);
        }

        .team-owner {
            font-size: 0.8rem;
            color: var(--text-muted);
        }

        .vs-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
        }

        .score-display {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-family: 'JetBrains Mono', monospace;
        }

        .score {
            font-size: 1.8rem;
            font-weight: 600;
            min-width: 60px;
            text-align: center;
        }

        .score.winning {
            color: var(--win);
        }

        .score.losing {
            color: var(--text-muted);
        }

        .score-divider {
            color: var(--text-muted);
            font-size: 1.2rem;
        }

        .expand-btn {
            width: 100%;
            padding: 0.75rem;
            background: var(--bg-hover);
            border: none;
            border-top: 1px solid var(--border);
            color: var(--text-muted);
            font-family: 'Outfit', sans-serif;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .expand-btn:hover {
            background: var(--bg-card);
            color: var(--text-secondary);
        }

        .roster-panel {
            display: none;
            padding: 1.5rem;
            border-top: 1px solid var(--border);
            background: rgba(0, 0, 0, 0.2);
        }

        .roster-panel.expanded {
            display: block;
        }

        .roster-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
        }

        .roster-column h4 {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-muted);
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border);
        }

        .player-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.03);
        }

        .player-row.bench {
            opacity: 0.4;
        }

        .player-info {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .position-tag {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.65rem;
            font-weight: 600;
            padding: 0.15rem 0.35rem;
            background: var(--bg-deep);
            border-radius: 0.25rem;
            color: var(--text-muted);
        }

        .player-name {
            font-size: 0.9rem;
        }

        .player-team {
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        .player-score {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            font-weight: 600;
        }

        /* Standings */
        .standings-table {
            width: 100%;
            border-collapse: collapse;
        }

        .standings-table th {
            text-align: left;
            padding: 1rem;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-muted);
            border-bottom: 1px solid var(--border);
        }

        .standings-table th.num {
            text-align: right;
        }

        .standings-table td {
            padding: 1rem;
            border-bottom: 1px solid var(--border);
        }

        .standings-table td.num {
            text-align: right;
            font-family: 'JetBrains Mono', monospace;
        }

        .standings-table tr:hover {
            background: var(--bg-hover);
        }

        .rank {
            font-family: 'JetBrains Mono', monospace;
            font-weight: 600;
            color: var(--text-muted);
        }

        .rank.playoffs {
            color: var(--accent-primary);
        }

        .rank.toilet-bowl {
            color: var(--accent-secondary);
        }

        .record {
            color: var(--text-secondary);
        }

        .rank-points {
            color: var(--accent-primary);
            font-weight: 600;
        }

        .top-half {
            color: var(--accent-tertiary);
        }

        .points-for {
            color: var(--text-secondary);
        }

        .points-against {
            color: var(--text-muted);
        }

        .team-code {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-left: 0.5rem;
        }

        .playoff-label {
            font-size: 0.7rem;
            padding: 0.15rem 0.4rem;
            border-radius: 0.25rem;
            margin-left: 0.5rem;
            font-weight: 600;
        }

        .playoff-label.playoffs {
            background: rgba(68, 136, 255, 0.15);
            color: var(--accent-primary);
        }

        .playoff-label.toilet {
            background: rgba(221, 34, 34, 0.15);
            color: var(--accent-secondary);
        }

        /* Team Pages */
        .team-selector {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-bottom: 2rem;
            justify-content: center;
        }

        .team-btn {
            padding: 0.75rem 1.25rem;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.9rem;
        }

        .team-btn:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
            border-color: var(--accent-primary);
        }

        .team-btn.active {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
            color: var(--bg-deep);
            font-weight: 600;
        }

        .team-header {
            text-align: center;
            margin-bottom: 2rem;
        }

        .team-header h2 {
            font-size: 2rem;
            color: var(--accent-primary);
            margin-bottom: 0.5rem;
        }

        .team-header .owner {
            color: var(--text-secondary);
            font-size: 1rem;
        }

        .roster-table {
            width: 100%;
            border-collapse: collapse;
            background: var(--bg-card);
            border-radius: 1rem;
            overflow: hidden;
        }

        .roster-table th,
        .roster-table td {
            padding: 0.75rem 1rem;
            text-align: left;
            border-bottom: 1px solid var(--border);
        }

        .roster-table th {
            background: var(--bg-hover);
            color: var(--text-secondary);
            font-weight: 600;
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .roster-table th.week-col {
            text-align: center;
            min-width: 50px;
        }

        .roster-table td.week-score {
            text-align: center;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
        }

        .roster-table td.week-score.starter {
            color: var(--accent-primary);
            font-weight: 600;
        }

        .roster-table td.week-score.bench {
            color: var(--text-muted);
        }

        .roster-table .player-name {
            font-weight: 500;
        }

        .roster-table .player-team {
            color: var(--text-secondary);
            font-size: 0.85rem;
        }

        .roster-table .position-group {
            background: var(--bg-deep);
            font-weight: 700;
            color: var(--accent-tertiary);
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .roster-table .total-row {
            background: var(--bg-hover);
            font-weight: 700;
        }

        .roster-table .total-row td {
            border-bottom: none;
        }

        .roster-table .total-row .week-score {
            color: var(--accent-primary);
        }

        .roster-table th.season-col {
            background: var(--bg-deep);
            border-left: 2px solid var(--border);
        }

        .roster-table td.season-total {
            border-left: 2px solid var(--border);
            font-weight: 600;
            color: var(--text-primary);
        }

        .roster-table .total-row td:last-child {
            border-left: 2px solid var(--border);
        }

        /* Draft Picks */
        .draft-picks-section {
            margin-top: 2rem;
        }

        .draft-picks-section h3 {
            color: var(--accent-primary);
            margin-bottom: 1rem;
            font-size: 1.5rem;
        }

        .picks-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1rem;
        }

        @media (max-width: 900px) {
            .picks-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 500px) {
            .picks-grid {
                grid-template-columns: 1fr;
            }
        }

        .picks-season {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 0.75rem;
            padding: 1rem;
        }

        .picks-season-header {
            font-weight: 700;
            color: var(--accent-primary);
            font-size: 1.2rem;
            margin-bottom: 0.75rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border);
        }

        .picks-draft-type {
            margin-bottom: 0.75rem;
        }

        .picks-type-label {
            color: var(--text-secondary);
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.25rem;
        }

        .picks-list {
            display: flex;
            flex-wrap: wrap;
            gap: 0.35rem;
        }

        .pick-item {
            padding: 0.2rem 0.5rem;
            border-radius: 0.25rem;
            font-size: 0.85rem;
            font-family: 'JetBrains Mono', monospace;
        }

        .pick-item.own {
            background: var(--bg-hover);
            color: var(--text-primary);
        }

        .pick-item.acquired {
            background: rgba(68, 136, 255, 0.2);
            color: var(--accent-primary);
            border: 1px solid var(--accent-primary);
        }

        .pick-from {
            color: var(--accent-tertiary);
            font-size: 0.75rem;
        }

        .pick-via {
            color: var(--text-muted);
            font-size: 0.7rem;
            font-style: italic;
        }

        .pick-condition {
            color: var(--text-secondary);
            font-size: 0.7rem;
            font-style: italic;
            font-family: inherit;
        }

        .pick-item-wrapper {
            display: inline-flex;
            flex-direction: column;
            gap: 0.15rem;
        }

        .pick-condition-icon {
            color: var(--accent-warning, #f0a020);
            margin-left: 0.25rem;
            cursor: help;
        }

        /* Schedule */
        .schedule-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 1rem;
        }

        .schedule-week {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 0.75rem;
            padding: 1rem;
        }

        .schedule-week.rivalry {
            border-color: var(--accent-secondary);
            background: linear-gradient(135deg, rgba(221, 34, 34, 0.05), transparent);
        }

        .schedule-week.current {
            border-color: var(--accent-primary);
            background: linear-gradient(135deg, rgba(68, 136, 255, 0.05), transparent);
        }

        .schedule-week.completed {
            opacity: 0.6;
        }

        .schedule-week-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border);
        }

        .schedule-week-title {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.1rem;
            letter-spacing: 0.05em;
        }

        .schedule-week-title.rivalry {
            color: var(--accent-secondary);
        }

        .schedule-week-badge {
            font-size: 0.65rem;
            padding: 0.15rem 0.4rem;
            border-radius: 0.25rem;
            font-weight: 600;
        }

        .schedule-week-badge.current {
            background: var(--accent-primary);
            color: var(--bg-deep);
        }

        .schedule-week-badge.completed {
            background: var(--border);
            color: var(--text-muted);
        }

        .schedule-matchup {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.4rem 0;
            font-size: 0.85rem;
        }

        .schedule-team {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
        }

        .schedule-vs {
            color: var(--text-muted);
            font-size: 0.7rem;
        }

        .schedule-matchup.with-scores {
            justify-content: center;
            gap: 0.5rem;
        }

        .schedule-matchup.with-scores .schedule-team {
            min-width: 2.5rem;
        }

        .schedule-matchup.with-scores .schedule-team:first-child {
            text-align: right;
        }

        .schedule-matchup.with-scores .schedule-team:last-child {
            text-align: left;
        }

        .schedule-score {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            min-width: 3rem;
            text-align: center;
        }

        .schedule-score:first-of-type {
            text-align: right;
        }

        .schedule-score:last-of-type {
            text-align: left;
        }

        .schedule-team.winner,
        .schedule-score.winner {
            color: var(--accent-primary);
            font-weight: 600;
        }

        .schedule-team.loser,
        .schedule-score.loser {
            color: var(--text-muted);
        }

        /* Playoff Styles */
        .schedule-week.playoffs {
            border-color: #ffd700;
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.08), rgba(255, 140, 0, 0.03));
        }

        .schedule-week.playoffs.current {
            border-width: 2px;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.2);
        }

        .schedule-week-title.playoffs {
            color: #ffd700;
            text-transform: uppercase;
        }

        .bracket-label {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 0.9rem;
            letter-spacing: 0.1em;
            padding: 0.5rem 0 0.25rem;
            margin-top: 0.5rem;
            border-top: 1px solid var(--border);
        }

        .bracket-label:first-child {
            margin-top: 0;
            border-top: none;
            padding-top: 0;
        }

        .bracket-label.playoffs {
            color: #ffd700;
        }

        .bracket-label.championship {
            color: #ffd700;
        }

        .bracket-label.consolation_cup {
            color: #C0C0C0;
        }

        .bracket-label.mid_bowl {
            color: #6b8e23;
        }

        .mid-bowl-breakdown {
            display: flex;
            flex-direction: column;
            font-size: 0.7rem;
            color: var(--text-muted);
            margin-top: 4px;
            gap: 2px;
        }

        .mid-bowl-breakdown span {
            text-align: center;
        }

        .mid-bowl-note {
            font-size: 0.7rem;
            color: #6b8e23;
            margin-top: 4px;
            text-align: center;
            font-style: italic;
        }

        .bracket-label.sewer_series {
            color: #708090;
        }

        .bracket-label.toilet_bowl {
            color: #a87c4f;
        }

        .playoff-matchup {
            background: rgba(255, 255, 255, 0.02);
            border-radius: 0.25rem;
            margin: 0.25rem 0;
            padding: 0.5rem !important;
        }

        .seed {
            font-size: 0.7rem;
            color: var(--text-muted);
            margin: 0 0.25rem;
        }

        .view-container {
            display: none;
        }

        .view-container.active {
            display: block;
        }

        /* Home Page */
        .home-container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .home-header {
            text-align: center;
            margin-bottom: 2.5rem;
            padding: 2rem;
            background: linear-gradient(135deg, rgba(68, 136, 255, 0.1), rgba(102, 153, 255, 0.05));
            border-radius: 1rem;
            border: 1px solid var(--border);
        }

        .home-title {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 2.5rem;
            letter-spacing: 0.05em;
            color: var(--accent-primary);
            margin-bottom: 1rem;
        }

        .home-blurb {
            color: var(--text-secondary);
            font-size: 1.1rem;
            line-height: 1.6;
            max-width: 700px;
            margin: 0 auto;
        }

        .home-section {
            margin-bottom: 2rem;
        }

        .home-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1.5rem;
            margin-bottom: 1.5rem;
        }

        @media (max-width: 900px) {
            .home-grid {
                grid-template-columns: 1fr;
            }
        }

        .home-card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 0.75rem;
            padding: 1.5rem;
        }

        .home-card-title {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.4rem;
            letter-spacing: 0.05em;
            color: var(--text-primary);
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border);
        }

        .home-transactions-card {
            max-width: 800px;
            margin: 0 auto;
        }

        .home-matchups {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .home-matchup {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1rem;
            background: var(--bg-hover);
            border-radius: 0.5rem;
            font-size: 0.9rem;
        }

        .home-matchup-team {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex: 1;
        }

        .home-matchup-team.winner {
            color: var(--win);
        }

        .home-matchup-team.loser {
            color: var(--text-muted);
        }

        .home-matchup-vs {
            color: var(--text-muted);
            font-size: 0.8rem;
            padding: 0 1rem;
        }

        .home-matchup-score {
            font-family: 'JetBrains Mono', monospace;
            font-weight: 600;
        }

        .home-standings {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .home-standing-row {
            display: flex;
            align-items: center;
            padding: 0.5rem 0.75rem;
            background: var(--bg-hover);
            border-radius: 0.35rem;
            font-size: 0.85rem;
        }

        .home-standing-rank {
            width: 2rem;
            font-family: 'JetBrains Mono', monospace;
            color: var(--text-muted);
        }

        .home-standing-team {
            flex: 1;
        }

        .home-standing-rp {
            font-family: 'JetBrains Mono', monospace;
            color: var(--accent-tertiary);
        }

        .home-standing-record {
            font-family: 'JetBrains Mono', monospace;
            color: var(--text-secondary);
            margin-left: 1rem;
            font-size: 0.8rem;
        }

        .home-transactions {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .home-transaction {
            padding: 0.75rem 1rem;
            background: var(--bg-hover);
            border-radius: 0.5rem;
            border-left: 3px solid var(--accent-primary);
        }

        .home-transaction-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.25rem;
        }

        .home-transaction-team {
            font-weight: 600;
            color: var(--text-primary);
        }

        .home-transaction-date {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        .home-transaction-text {
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        /* Offseason specific styles */
        .home-champion-section {
            text-align: center;
            margin-bottom: 2rem;
            padding: 2rem;
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.1), rgba(255, 215, 0, 0.02));
            border: 2px solid rgba(255, 215, 0, 0.3);
            border-radius: 1rem;
        }

        .home-banner-container {
            margin-bottom: 1.5rem;
        }

        .home-banner-container img {
            max-width: 400px;
            width: 100%;
            height: auto;
            border-radius: 0.5rem;
            box-shadow: 0 10px 40px rgba(255, 215, 0, 0.2);
        }

        .home-champion-title {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 2rem;
            letter-spacing: 0.05em;
            color: #ffd700;
        }

        .home-championship {
            text-align: center;
            padding: 1.5rem;
        }

        .home-championship-matchup {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 2rem;
            margin-bottom: 1rem;
        }

        .home-championship-team {
            text-align: center;
        }

        .home-championship-name {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 0.25rem;
        }

        .home-championship-name.winner {
            color: #ffd700;
        }

        .home-championship-score {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.5rem;
            font-weight: 700;
        }

        .home-championship-score.winner {
            color: #ffd700;
        }

        .home-championship-vs {
            color: var(--text-muted);
            font-size: 1.2rem;
        }

        .home-championship-label {
            display: inline-block;
            padding: 0.25rem 1rem;
            background: rgba(255, 215, 0, 0.2);
            border: 1px solid rgba(255, 215, 0, 0.4);
            border-radius: 2rem;
            color: #ffd700;
            font-size: 0.8rem;
            font-weight: 600;
            letter-spacing: 0.1em;
        }

        .home-draft-order {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 0.75rem;
        }

        @media (max-width: 700px) {
            .home-draft-order {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        .home-draft-pick {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem 1rem;
            background: var(--bg-hover);
            border-radius: 0.5rem;
        }

        .home-draft-pick-num {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--accent-primary);
        }

        .home-draft-pick-team {
            font-size: 0.9rem;
        }

        /* Top Scorers */
        .home-top-scorers {
            margin-top: 1.5rem;
            padding-top: 1rem;
            border-top: 1px solid var(--border);
        }

        .home-scorers-title {
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.75rem;
        }

        .home-scorer-row {
            display: flex;
            align-items: center;
            padding: 0.4rem 0.5rem;
            background: var(--bg-hover);
            border-radius: 0.35rem;
            margin-bottom: 0.4rem;
            font-size: 0.85rem;
        }

        .home-scorer-pos {
            width: 2.5rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        .home-scorer-name {
            flex: 1;
        }

        .home-scorer-pts {
            font-family: 'JetBrains Mono', monospace;
            color: var(--accent-tertiary);
            font-weight: 600;
        }

        /* Offseason Transactions */
        .home-transaction-item {
            padding: 0.75rem 1rem;
            background: var(--bg-hover);
            border-radius: 0.5rem;
            border-left: 3px solid var(--accent-primary);
            margin-bottom: 0.5rem;
        }

        .home-tx-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.25rem;
        }

        .home-tx-team {
            font-family: 'JetBrains Mono', monospace;
            font-weight: 600;
            color: var(--accent-primary);
        }

        .home-tx-type {
            font-size: 0.75rem;
            color: var(--text-muted);
            text-transform: capitalize;
        }

        .home-tx-details {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
            font-size: 0.85rem;
        }

        .home-tx-details .tx-add {
            color: var(--win);
        }

        .home-tx-details .tx-drop {
            color: var(--loss);
        }

        .home-transactions-link {
            display: inline-block;
            margin-top: 1rem;
            padding: 0.5rem 1rem;
            background: var(--accent-primary);
            color: var(--bg-primary);
            text-decoration: none;
            border-radius: 0.35rem;
            font-size: 0.85rem;
            font-weight: 600;
            text-align: center;
            transition: background 0.2s;
        }

        .home-transactions-link:hover {
            background: var(--accent-secondary);
        }

        .home-no-transactions {
            color: var(--text-muted);
            font-style: italic;
            text-align: center;
            padding: 1rem;
        }

        /* Stats Leaders */
        .stats-position-selector {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-bottom: 2rem;
        }

        .stats-pos-btn {
            padding: 0.5rem 1rem;
            font-family: 'Outfit', sans-serif;
            font-weight: 600;
            font-size: 0.9rem;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .stats-pos-btn:hover {
            border-color: var(--accent-primary);
            color: var(--accent-primary);
        }

        .stats-pos-btn.active {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
            color: var(--bg-deep);
        }

        .stats-leaders-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
            gap: 1.5rem;
        }

        .stats-position-card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 0.75rem;
            overflow: hidden;
        }

        .stats-position-header {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.3rem;
            letter-spacing: 0.1em;
            padding: 0.75rem 1rem;
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.1), rgba(0, 255, 136, 0.02));
            border-bottom: 1px solid var(--border);
            color: var(--accent-primary);
        }

        .stats-leader-row {
            display: grid;
            grid-template-columns: 2rem 1fr auto;
            align-items: center;
            padding: 0.6rem 1rem;
            gap: 0.75rem;
            border-bottom: 1px solid var(--border);
            transition: background 0.2s ease;
        }

        .stats-leader-row:last-child {
            border-bottom: none;
        }

        .stats-leader-row:hover {
            background: rgba(0, 255, 136, 0.03);
        }

        .stats-leader-row.rank-1 {
            background: linear-gradient(90deg, rgba(255, 215, 0, 0.15), transparent);
        }

        .stats-leader-row.rank-2 {
            background: linear-gradient(90deg, rgba(192, 192, 192, 0.1), transparent);
        }

        .stats-leader-row.rank-3 {
            background: linear-gradient(90deg, rgba(205, 127, 50, 0.1), transparent);
        }

        .stats-rank {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.1rem;
            color: var(--text-muted);
            text-align: center;
        }

        .stats-leader-row.rank-1 .stats-rank {
            color: #ffd700;
        }

        .stats-leader-row.rank-2 .stats-rank {
            color: #c0c0c0;
        }

        .stats-leader-row.rank-3 .stats-rank {
            color: #cd7f32;
        }

        .stats-player-info {
            display: flex;
            flex-direction: column;
            gap: 0.15rem;
            min-width: 0;
        }

        .stats-player-name {
            font-weight: 600;
            font-size: 0.95rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .stats-player-meta {
            display: flex;
            gap: 0.5rem;
            font-size: 0.75rem;
            color: var(--text-muted);
        }

        .stats-nfl-team {
            font-family: 'JetBrains Mono', monospace;
            color: var(--accent-secondary);
        }

        .stats-fantasy-team {
            opacity: 0.8;
        }

        .stats-points {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1rem;
            font-weight: 600;
            color: var(--accent-primary);
            text-align: right;
        }

        .stats-view-all {
            display: block;
            text-align: center;
            padding: 0.75rem;
            font-size: 0.85rem;
            color: var(--accent-primary);
            background: transparent;
            border: none;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .stats-view-all:hover {
            background: rgba(0, 255, 136, 0.05);
        }

        /* Team Stats Page */
        .team-stats-content {
            max-width: 1200px;
            margin: 0 auto;
        }

        .team-stats-section {
            margin-bottom: 2.5rem;
        }

        .team-stats-section h3 {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.5rem;
            color: var(--accent-primary);
            margin-bottom: 1rem;
            letter-spacing: 0.05em;
        }

        .stats-table-wrapper {
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }

        .team-stats-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9rem;
        }

        .team-stats-table th,
        .team-stats-table td {
            padding: 0.75rem 0.5rem;
            text-align: left;
            border-bottom: 1px solid rgba(255, 255, 255, 0.08);
        }

        .team-stats-table th {
            background: rgba(0, 0, 0, 0.3);
            color: var(--text-muted);
            font-weight: 600;
            text-transform: uppercase;
            font-size: 0.75rem;
            letter-spacing: 0.05em;
            position: sticky;
            top: 0;
        }

        .team-stats-table th.num,
        .team-stats-table td.num {
            text-align: right;
        }

        .team-stats-table td.team-col {
            white-space: nowrap;
        }

        .team-stats-table .team-abbrev {
            font-weight: 700;
            color: var(--accent-primary);
            margin-right: 0.5rem;
        }

        .team-stats-table .team-name-short {
            color: var(--text-muted);
            font-size: 0.85rem;
        }

        .team-stats-table .positive {
            color: #22c55e;
        }

        .team-stats-table .negative {
            color: #ef4444;
        }

        .team-stats-table .streak-win {
            color: #22c55e;
            font-weight: 600;
        }

        .team-stats-table .streak-loss {
            color: #ef4444;
        }

        .week-ref {
            color: var(--text-muted);
            font-size: 0.75rem;
            margin-left: 0.25rem;
        }

        .team-stats-table tbody tr:hover {
            background: rgba(255, 255, 255, 0.03);
        }

        /* Advanced Stats Grid */
        .advanced-stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 1.25rem;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 8px;
            padding: 1rem;
        }

        .stat-card-title {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.1rem;
            color: var(--text-muted);
            margin-bottom: 0.75rem;
            letter-spacing: 0.03em;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding-bottom: 0.5rem;
        }

        .stat-card-row {
            display: flex;
            align-items: center;
            padding: 0.4rem 0;
            font-size: 0.9rem;
        }

        .stat-card-row .rank {
            width: 24px;
            color: var(--text-muted);
            font-weight: 500;
        }

        .stat-card-row .team {
            flex: 1;
            font-weight: 600;
            color: var(--accent-primary);
        }

        .stat-card-row .value {
            font-weight: 600;
            min-width: 50px;
            text-align: right;
        }

        .stat-card-row .value.positive {
            color: #22c55e;
        }

        .stat-card-row .value.negative {
            color: #ef4444;
        }

        .stat-card-row .context {
            color: var(--text-muted);
            font-size: 0.8rem;
            margin-left: 0.5rem;
            min-width: 30px;
        }

        /* Mobile adjustments for team stats */
        @media (max-width: 768px) {
            .team-stats-table {
                font-size: 0.8rem;
            }

            .team-stats-table th,
            .team-stats-table td {
                padding: 0.5rem 0.3rem;
            }

            .team-stats-table .team-name-short {
                display: none;
            }

            .advanced-stats-grid {
                grid-template-columns: 1fr;
            }
        }

        /* Page titles */
        .page-title {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 2.5rem;
            letter-spacing: 0.1em;
            text-align: center;
            margin-bottom: 2rem;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-tertiary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        /* Banner Room */
        .banners-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 2rem;
            justify-items: center;
        }

        .banner-item {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 1rem;
            padding: 1rem;
            text-align: center;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .banner-item:hover {
            transform: scale(1.02);
            box-shadow: 0 10px 40px rgba(68, 136, 255, 0.1);
        }

        .banner-item img {
            max-width: 100%;
            height: auto;
            border-radius: 0.5rem;
        }

        /* Hall of Fame */
        .hof-content {
            max-width: 900px;
            margin: 0 auto;
        }

        .hof-section {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 1rem;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
        }

        .hof-section-title {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.5rem;
            letter-spacing: 0.05em;
            color: var(--accent-primary);
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border);
        }

        .formula-note {
            font-size: 0.85rem;
            color: var(--text-muted);
            margin-top: 0.75rem;
            padding: 0.5rem 0.75rem;
            background: rgba(255,255,255,0.03);
            border-radius: 4px;
            border-left: 3px solid var(--accent-secondary);
        }

        .formula-section {
            margin-top: 2rem;
            padding-top: 1rem;
            border-top: 1px solid var(--border);
        }

        .formula-section .formula-note {
            margin-bottom: 0.5rem;
        }

        .hof-years-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 1rem;
        }

        .hof-year {
            background: rgba(255,255,255,0.02);
            border-radius: 8px;
            padding: 1rem;
            border: 1px solid var(--border);
        }

        .hof-year-title {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.3rem;
            color: var(--accent-tertiary);
            margin-bottom: 0.5rem;
            border-bottom: 1px solid var(--border);
            padding-bottom: 0.5rem;
        }

        .hof-year-results {
            padding-left: 0;
            list-style: none;
        }

        .hof-year-results li {
            color: var(--text-secondary);
            margin-bottom: 0.35rem;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .hof-year-results li::before {
            font-size: 0.75rem;
            width: 1.5rem;
            text-align: center;
            flex-shrink: 0;
        }

        .hof-year-results li:first-child {
            color: #ffd700;
            font-weight: 600;
        }

        .hof-year-results li:first-child::before {
            content: 'ðŸ¥‡';
        }

        .hof-year-results li:nth-child(2) {
            color: #c0c0c0;
        }

        .hof-year-results li:nth-child(2)::before {
            content: 'ðŸ¥ˆ';
        }

        .hof-year-results li:nth-child(3) {
            color: #cd7f32;
        }

        .hof-year-results li:nth-child(3)::before {
            content: 'ðŸ¥‰';
        }

        .hof-year-results li:nth-child(n+4)::before {
            content: '';
        }

        /* New season finishes cards */
        .hof-seasons-list {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .hof-season-card {
            background: linear-gradient(135deg, rgba(255,255,255,0.03) 0%, rgba(255,255,255,0.01) 100%);
            border-radius: 12px;
            border: 1px solid var(--border);
            overflow: hidden;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }

        .hof-season-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(0,0,0,0.3);
        }

        .hof-season-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.25rem;
            background: linear-gradient(90deg, rgba(255,215,0,0.15) 0%, transparent 50%);
            border-bottom: 1px solid var(--border);
        }

        .hof-season-year {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 2rem;
            color: var(--accent-tertiary);
            line-height: 1;
        }

        .hof-season-champion {
            font-size: 1.2rem;
            font-weight: 600;
            color: #ffd700;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .champion-crown {
            font-size: 1.4rem;
        }

        .hof-season-body {
            padding: 1rem 1.25rem;
        }

        .hof-season-podium {
            display: flex;
            gap: 1.5rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }

        .podium-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: var(--text-secondary);
            font-size: 0.95rem;
        }

        .podium-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 0.15rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .podium-badge.silver {
            background: linear-gradient(135deg, #c0c0c0 0%, #a8a8a8 100%);
            color: #1a1a1a;
        }

        .podium-badge.bronze {
            background: linear-gradient(135deg, #cd7f32 0%, #a66828 100%);
            color: #1a1a1a;
        }

        .hof-season-stats {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 0.5rem;
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            padding: 0.75rem;
            margin-bottom: 1rem;
        }

        .hof-season-stats .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }

        .hof-season-stats .stat-label {
            font-size: 0.7rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .hof-season-stats .stat-value {
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-primary);
        }

        /* Detailed stats layout */
        .hof-season-stats-detailed {
            background: rgba(0,0,0,0.2);
            border-radius: 8px;
            padding: 0.75rem 1rem;
            margin-bottom: 1rem;
        }

        .hof-season-stats-detailed .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            padding: 0.4rem 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }

        .hof-season-stats-detailed .stat-row:last-child {
            border-bottom: none;
        }

        .hof-season-stats-detailed .stat-label {
            font-size: 0.8rem;
            color: var(--text-muted);
            flex-shrink: 0;
        }

        .hof-season-stats-detailed .stat-value {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-primary);
            text-align: right;
        }

        .hof-season-stats-detailed .stat-context {
            font-weight: 400;
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-left: 0.25rem;
        }

        .hof-season-stats-detailed .rivalry-row {
            background: linear-gradient(90deg, rgba(255,215,0,0.1) 0%, transparent 100%);
            margin: 0.25rem -0.5rem 0;
            padding: 0.4rem 0.5rem;
            border-radius: 4px;
        }

        .hof-season-stats-detailed .rivalry-row .stat-label {
            color: #ffd700;
        }

        .hof-toilet-bowl {
            font-size: 0.85rem;
            color: var(--text-muted);
            padding: 0.5rem 0.75rem;
            background: rgba(139, 69, 19, 0.2);
            border-radius: 6px;
            border-left: 3px solid #8b4513;
        }

        @media (max-width: 768px) {
            .hof-season-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 0.5rem;
            }

            .hof-season-stats {
                grid-template-columns: repeat(3, 1fr);
            }

            .hof-season-podium {
                flex-direction: column;
                gap: 0.5rem;
            }
        }

        .table-scroll-wrapper {
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
            margin: 0 -0.5rem;
            padding: 0 0.5rem;
        }

        .owner-stats-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9rem;
            min-width: 500px;
        }

        .owner-stats-table th {
            text-align: left;
            padding: 0.75rem 0.5rem;
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
            border-bottom: 1px solid var(--border);
        }

        .owner-stats-table td {
            padding: 0.75rem 0.5rem;
            border-bottom: 1px solid var(--border);
        }

        .owner-stats-table tr:hover {
            background: var(--bg-hover);
        }

        .rings {
            color: #ffd700;
        }

        /* Rivalry Table */
        .rivalry-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9rem;
            min-width: 400px;
        }

        .rivalry-table th {
            text-align: left;
            padding: 0.75rem 0.5rem;
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
            border-bottom: 1px solid var(--border);
        }

        .rivalry-table td {
            padding: 0.75rem 0.5rem;
            border-bottom: 1px solid var(--border);
        }

        .rivalry-table tr:hover {
            background: var(--bg-hover);
        }

        .rivalry-leader {
            font-weight: bold;
            color: var(--accent);
        }

        .rivalry-record {
            text-align: center;
            font-family: var(--font-mono, monospace);
            font-weight: 600;
        }

        .rivalry-points {
            color: var(--text-muted);
            font-size: 0.85rem;
        }

        .rivalry-week-row {
            background: linear-gradient(90deg, rgba(255, 215, 0, 0.1) 0%, rgba(255, 215, 0, 0.05) 50%, rgba(255, 215, 0, 0.1) 100%);
            border-left: 3px solid #ffd700;
        }

        .rivalry-week-row:hover {
            background: linear-gradient(90deg, rgba(255, 215, 0, 0.2) 0%, rgba(255, 215, 0, 0.1) 50%, rgba(255, 215, 0, 0.2) 100%);
        }

        .rivalry-week-indicator {
            color: #ffd700;
            font-size: 0.9rem;
        }

        .record-item {
            padding: 0.5rem 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            color: var(--text-secondary);
        }

        .record-item:last-child {
            border-bottom: none;
        }

        .record-subsection {
            margin-top: 1rem;
        }

        .record-subsection-title {
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 0.5rem;
        }

        /* Constitution */
        .constitution-content {
            max-width: 800px;
            margin: 0 auto;
        }

        .constitution-article {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 1rem;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
        }

        .article-title {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.5rem;
            letter-spacing: 0.05em;
            color: var(--accent-primary);
            margin-bottom: 1rem;
        }

        .article-section {
            margin-bottom: 1.5rem;
        }

        .section-title {
            font-weight: 600;
            color: var(--accent-tertiary);
            margin-bottom: 0.5rem;
            font-size: 1.1rem;
        }

        .section-content {
            padding-left: 1rem;
            color: var(--text-secondary);
        }

        .section-content p {
            margin-bottom: 0.5rem;
        }

        .section-subheader {
            font-weight: 600;
            color: var(--text-primary);
            margin-top: 0.75rem;
            margin-bottom: 0.25rem;
        }

        .content-header {
            color: var(--accent-tertiary);
            font-weight: 500;
            margin-top: 0.75rem;
            margin-bottom: 0.25rem;
        }

        .content-item {
            color: var(--text-secondary);
            margin-left: 1.5rem;
            margin-bottom: 0.35rem;
            line-height: 1.5;
        }

        .content-subitem {
            color: var(--text-muted);
            margin-left: 3rem;
            margin-bottom: 0.25rem;
            font-size: 0.95rem;
            line-height: 1.5;
        }

        .item-num {
            color: var(--accent-primary);
            font-weight: 600;
            margin-right: 0.5rem;
            font-family: 'JetBrains Mono', monospace;
        }

        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }

            .logo {
                font-size: 1.5rem;
                letter-spacing: 0.05em;
            }

            .matchup-header {
                grid-template-columns: 1fr;
                text-align: center;
                gap: 1rem;
            }

            .team, .team.right {
                text-align: center;
            }

            .roster-grid {
                grid-template-columns: 1fr;
            }

            .standings-table th,
            .standings-table td {
                padding: 0.5rem;
                font-size: 0.8rem;
            }

            /* Hall of Fame mobile styles */
            .hof-subnav {
                flex-wrap: wrap;
            }

            .hof-subnav-btn {
                font-size: 0.8rem;
                padding: 0.5rem 0.75rem;
            }

            .table-scroll-wrapper {
                margin: 0 -1rem;
                padding: 0 1rem;
                position: relative;
            }

            .table-scroll-wrapper::after {
                content: 'â†’';
                position: absolute;
                right: 0.25rem;
                top: 50%;
                transform: translateY(-50%);
                color: var(--text-muted);
                font-size: 1.5rem;
                opacity: 0.5;
                pointer-events: none;
                animation: scrollHint 1.5s ease-in-out infinite;
            }

            @keyframes scrollHint {
                0%, 100% { opacity: 0.3; transform: translateY(-50%) translateX(0); }
                50% { opacity: 0.6; transform: translateY(-50%) translateX(5px); }
            }

            .owner-stats-table {
                font-size: 0.75rem;
                min-width: 450px;
            }

            .owner-stats-table th,
            .owner-stats-table td {
                padding: 0.5rem 0.35rem;
                white-space: nowrap;
            }

            .owner-stats-table th {
                font-size: 0.55rem;
            }

            .hof-section {
                padding: 1rem;
            }

            .hof-section-title {
                font-size: 1rem;
            }

            .hof-year {
                padding: 0.75rem;
            }

            .hof-year-title {
                font-size: 1rem;
            }

            .hof-year-results {
                font-size: 0.85rem;
            }

            .hof-year-results li {
                padding: 0.35rem 0;
            }

            .record-item {
                font-size: 0.85rem;
            }

            /* Jamboree table mobile */
            .jamboree-table {
                font-size: 0.8rem;
            }

            .jamboree-table th,
            .jamboree-table td {
                padding: 0.5rem 0.35rem;
            }

            /* Hall of Fame years grid mobile */
            .hof-years-grid {
                grid-template-columns: 1fr;
                gap: 0.75rem;
            }

            .hof-year {
                padding: 0.75rem;
            }

            .hof-year-title {
                font-size: 1.1rem;
            }

            .hof-year-results li {
                font-size: 0.8rem;
            }
        }

        /* Transactions */
        .transactions-season-selector {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            justify-content: center;
        }

        .season-btn {
            padding: 0.5rem 1.25rem;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.95rem;
            font-weight: 500;
        }

        .season-btn:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
            border-color: var(--accent-primary);
        }

        .season-btn.active {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
            color: var(--bg-deep);
            font-weight: 600;
        }

        .transactions-content {
            max-width: 900px;
            margin: 0 auto;
        }

        .transactions-season {
            margin-bottom: 2rem;
        }

        .transactions-week {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 0.75rem;
            margin-bottom: 1rem;
            overflow: hidden;
        }

        .transactions-week-header {
            background: var(--bg-hover);
            padding: 0.75rem 1rem;
            font-weight: 600;
            color: var(--accent-tertiary);
            border-bottom: 1px solid var(--border);
        }

        .transaction-item {
            padding: 1rem;
            border-bottom: 1px solid var(--border);
        }

        .transaction-item:last-child {
            border-bottom: none;
        }

        .transaction-title {
            color: var(--text-primary);
            font-weight: 600;
            margin-bottom: 0.5rem;
        }

        .transaction-details {
            padding-left: 1rem;
        }

        .transaction-subheader {
            color: var(--accent-tertiary);
            font-weight: 500;
            margin-top: 0.5rem;
            margin-bottom: 0.25rem;
        }

        .transaction-list-item {
            color: var(--text-secondary);
            margin-left: 1rem;
            font-size: 0.9rem;
            line-height: 1.5;
        }

        /* Drafts */
        .drafts-tabs {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            justify-content: center;
        }

        .drafts-tabs .season-btn {
            font-size: 0.85rem;
            padding: 0.4rem 0.9rem;
        }

        .drafts-content {
            max-width: 1100px;
            margin: 0 auto;
        }

        .draft-info {
            text-align: center;
            color: var(--text-secondary);
            margin-bottom: 1rem;
            font-size: 0.9rem;
        }

        .draft-round {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 0.75rem;
            margin-bottom: 1rem;
            overflow: hidden;
        }

        .draft-round-header {
            background: var(--bg-hover);
            padding: 0.75rem 1rem;
            font-weight: 600;
            color: var(--accent-tertiary);
            border-bottom: 1px solid var(--border);
        }

        .draft-picks-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 0;
        }

        .draft-pick {
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--border);
            border-right: 1px solid var(--border);
            display: flex;
            align-items: flex-start;
            gap: 0.75rem;
        }

        .draft-pick:last-child {
            border-bottom: none;
        }

        .pick-number {
            background: var(--accent-primary);
            color: var(--bg-deep);
            font-weight: 700;
            font-size: 0.75rem;
            min-width: 2rem;
            height: 2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 0.375rem;
            flex-shrink: 0;
        }

        .pick-details {
            flex: 1;
            min-width: 0;
        }

        .pick-team {
            color: var(--text-secondary);
            font-size: 0.8rem;
            margin-bottom: 0.25rem;
        }

        .pick-player {
            color: var(--text-primary);
            font-weight: 500;
            font-size: 0.95rem;
        }

        .pick-dropped {
            color: var(--text-muted);
            font-size: 0.8rem;
            margin-top: 0.25rem;
        }

        .pick-dropped span {
            color: #e06c75;
        }

        .pick-pass {
            color: var(--text-muted);
            font-style: italic;
        }

        @media (max-width: 768px) {
            .draft-picks-grid {
                grid-template-columns: 1fr;
            }
            
            .draft-pick {
                border-right: none;
            }

            .drafts-tabs {
                gap: 0.25rem;
            }

            .drafts-tabs .season-btn {
                font-size: 0.75rem;
                padding: 0.35rem 0.6rem;
            }
        }

        /* Lineup Form Styles */
        .lineup-form-container {
            max-width: 900px;
            margin: 0 auto;
        }

        .auth-card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 1rem;
            padding: 2rem;
            max-width: 400px;
            margin: 0 auto;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .auth-card h3 {
            text-align: center;
            color: var(--accent-primary);
            margin-bottom: 0.5rem;
        }

        .lineup-select, .lineup-input {
            padding: 0.75rem 1rem;
            font-family: 'Outfit', sans-serif;
            font-size: 1rem;
            background: var(--bg-deep);
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            color: var(--text-primary);
            transition: border-color 0.2s;
        }

        .lineup-select:focus, .lineup-input:focus {
            outline: none;
            border-color: var(--accent-primary);
        }

        .lineup-btn {
            padding: 0.75rem 1.5rem;
            font-family: 'Outfit', sans-serif;
            font-weight: 600;
            font-size: 0.95rem;
            border: none;
            border-radius: 0.5rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .lineup-btn.primary {
            background: var(--accent-primary);
            color: var(--bg-deep);
        }

        .lineup-btn.primary:hover {
            background: var(--accent-tertiary);
            transform: translateY(-1px);
        }

        .lineup-btn.primary:disabled {
            background: var(--text-muted);
            cursor: not-allowed;
            transform: none;
        }

        .lineup-btn.secondary {
            background: var(--bg-hover);
            color: var(--text-secondary);
            border: 1px solid var(--border);
        }

        .lineup-btn.secondary:hover {
            color: var(--text-primary);
            border-color: var(--accent-primary);
        }

        .lineup-btn.large {
            padding: 1rem 2rem;
            font-size: 1.1rem;
        }

        .lineup-error {
            color: var(--accent-secondary);
            font-size: 0.9rem;
            text-align: center;
            min-height: 1.2rem;
        }

        .editor-header {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
        }

        .editor-header h3 {
            color: var(--text-primary);
            font-size: 1.5rem;
            margin: 0;
        }

        .week-badge {
            background: var(--accent-primary);
            color: var(--bg-deep);
            padding: 0.25rem 0.75rem;
            border-radius: 1rem;
            font-weight: 600;
            font-size: 0.85rem;
        }

        .lineup-instructions {
            background: rgba(68, 136, 255, 0.1);
            border: 1px solid rgba(68, 136, 255, 0.3);
            border-radius: 0.5rem;
            padding: 1rem;
            margin-bottom: 1.5rem;
            color: var(--text-secondary);
        }

        .position-groups {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .position-group-card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 0.75rem;
            overflow: hidden;
        }

        .position-group-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1rem;
            background: var(--bg-hover);
            border-bottom: 1px solid var(--border);
        }

        .position-label {
            font-weight: 700;
            color: var(--accent-tertiary);
            font-size: 1rem;
        }

        .starter-count {
            font-size: 0.85rem;
            color: var(--text-muted);
        }

        .starter-count.complete {
            color: var(--win);
        }

        .starter-count.incomplete {
            color: var(--accent-secondary);
        }

        .player-options {
            display: flex;
            flex-direction: column;
        }

        .player-option {
            display: flex;
            align-items: center;
            padding: 0.75rem 1rem;
            cursor: pointer;
            transition: all 0.15s;
            border-bottom: 1px solid var(--border);
        }

        .player-option:last-child {
            border-bottom: none;
        }

        .player-option:hover {
            background: var(--bg-hover);
        }

        .player-option.selected {
            background: rgba(68, 136, 255, 0.15);
            border-left: 3px solid var(--accent-primary);
        }

        .player-option .starter-indicator {
            width: 24px;
            height: 24px;
            border: 2px solid var(--border);
            border-radius: 50%;
            margin-right: 1rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s;
        }

        .player-option.selected .starter-indicator {
            background: var(--accent-primary);
            border-color: var(--accent-primary);
        }

        .player-option.selected .starter-indicator::after {
            content: 'âœ“';
            color: var(--bg-deep);
            font-weight: bold;
            font-size: 0.8rem;
        }

        .player-option .player-details {
            flex: 1;
        }

        .player-option .player-name {
            font-weight: 600;
            color: var(--text-primary);
        }

        .player-option .player-team {
            color: var(--text-muted);
            font-size: 0.85rem;
            margin-left: 0.5rem;
        }

        .lineup-actions {
            margin-top: 2rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
        }

        .lineup-summary {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        .lineup-summary.valid {
            color: var(--win);
        }

        .lineup-summary.invalid {
            color: var(--accent-secondary);
        }

        .lineup-comment-section {
            margin: 1rem 0;
            width: 100%;
        }

        .lineup-comment-section label {
            display: block;
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-bottom: 0.5rem;
        }

        .lineup-comment {
            width: 100%;
            min-height: 60px;
            padding: 0.75rem;
            background: var(--card-bg);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-family: inherit;
            font-size: 0.9rem;
            resize: vertical;
        }

        .lineup-comment:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 2px rgba(231, 76, 60, 0.2);
        }

        .lineup-comment::placeholder {
            color: var(--text-muted);
        }

        .player-status {
            font-size: 0.75rem;
            padding: 2px 6px;
            border-radius: 4px;
            margin-left: 0.5rem;
            font-weight: 500;
        }

        .player-status.bye {
            background: rgba(231, 76, 60, 0.15);
            color: #e74c3c;
        }

        .player-status.not-played {
            background: rgba(241, 196, 15, 0.15);
            color: #f1c40f;
        }

        /* Game time colors based on day/time */
        .player-status.game-time-thursday {
            background: rgba(180, 167, 214, 0.3);
            color: #B4A7D6;
        }

        .player-status.game-time-frisat {
            background: rgba(194, 123, 160, 0.3);
            color: #C27BA0;
        }

        .player-status.game-time-sun-morning {
            background: rgba(244, 204, 204, 0.3);
            color: #F4CCCC;
        }

        .player-status.game-time-sun-afternoon {
            background: rgba(255, 229, 153, 0.3);
            color: #FFE599;
        }

        .player-status.game-time-sun-night {
            background: rgba(182, 215, 168, 0.3);
            color: #B6D7A8;
        }

        .player-status.game-time-monday {
            background: rgba(164, 194, 244, 0.3);
            color: #A4C2F4;
        }

        .submit-status {
            margin-top: 1rem;
            padding: 1rem;
            border-radius: 0.5rem;
            text-align: center;
            font-weight: 500;
        }

        .submit-status.success {
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid var(--win);
            color: var(--win);
        }

        .submit-status.error {
            background: rgba(255, 51, 102, 0.1);
            border: 1px solid var(--accent-secondary);
            color: var(--accent-secondary);
        }

        .submit-status.loading {
            background: rgba(68, 136, 255, 0.1);
            border: 1px solid var(--accent-primary);
            color: var(--accent-primary);
        }

        .submit-status:empty {
            display: none;
        }

        /* Locked player styling */
        .player-option.locked {
            opacity: 0.7;
            cursor: not-allowed;
            background: rgba(255, 170, 0, 0.1);
        }

        .player-option.locked .starter-indicator {
            border-color: var(--tie);
            background: rgba(255, 170, 0, 0.2);
            font-size: 0.7rem;
        }

        .player-option.locked.selected {
            background: rgba(255, 170, 0, 0.15);
            border-left: 3px solid var(--tie);
        }

        .locked-label {
            display: inline-block;
            margin-left: 0.5rem;
            padding: 0.1rem 0.4rem;
            font-size: 0.7rem;
            font-weight: 600;
            background: var(--tie);
            color: var(--bg-deep);
            border-radius: 0.25rem;
        }

        /* Manage Roster / Transaction Styles */
        .manage-container {
            max-width: 1000px;
            margin: 0 auto;
        }

        .manage-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--border);
        }

        .manage-header h3 {
            margin: 0;
            font-size: 1.25rem;
        }

        .transaction-tabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
            border-bottom: 2px solid var(--border);
            padding-bottom: 0.5rem;
        }

        .tx-tab {
            padding: 0.6rem 1.25rem;
            font-family: 'Outfit', sans-serif;
            font-weight: 500;
            font-size: 0.9rem;
            background: transparent;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            transition: all 0.2s ease;
            border-radius: 0.5rem 0.5rem 0 0;
            position: relative;
        }

        .tx-tab:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
        }

        .tx-tab.active {
            background: var(--bg-card);
            color: var(--accent-primary);
            font-weight: 600;
        }

        .tx-tab.active::after {
            content: '';
            position: absolute;
            bottom: -0.5rem;
            left: 0;
            right: 0;
            height: 2px;
            background: var(--accent-primary);
        }

        .tx-content {
            display: none;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 1rem;
            padding: 1.5rem;
        }

        .tx-content.active {
            display: block;
        }

        .tx-description {
            margin-bottom: 1.5rem;
            padding: 1rem;
            background: var(--bg-deep);
            border-radius: 0.5rem;
            color: var(--text-secondary);
        }

        .tx-description p {
            margin: 0 0 0.5rem 0;
        }

        .tx-description p:last-child {
            margin-bottom: 0;
        }

        .deadline-warning {
            font-weight: 600;
        }
        
        .deadline-warning.trading-open {
            color: #4ade80;
        }
        
        .deadline-warning.trading-blocked {
            color: #f87171;
        }
        
        .deadline-warning.trading-normal {
            color: var(--text-muted);
        }

        .tx-section {
            margin-bottom: 1.5rem;
        }
        
        .team-name-editor {
            display: flex;
            gap: 0.75rem;
            align-items: center;
        }
        
        .team-name-editor input {
            flex: 1;
            max-width: 400px;
        }
        
        .team-name-section {
            background: rgba(255, 255, 255, 0.03);
            padding: 1rem;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .tx-section h4 {
            margin: 0 0 0.75rem 0;
            font-size: 1rem;
            color: var(--text-primary);
        }

        .player-list {
            display: grid;
            gap: 0.5rem;
        }

        .tx-player {
            display: flex;
            align-items: center;
            padding: 0.75rem 1rem;
            background: var(--bg-deep);
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .tx-player:hover {
            background: var(--bg-hover);
            border-color: var(--accent-tertiary);
        }

        .tx-player.selected {
            background: rgba(68, 136, 255, 0.15);
            border-color: var(--accent-primary);
            border-left: 3px solid var(--accent-primary);
        }

        .tx-player.unavailable {
            opacity: 0.5;
            cursor: not-allowed;
            text-decoration: line-through;
        }

        .tx-player .position-tag {
            display: inline-block;
            padding: 0.25rem 0.5rem;
            background: var(--accent-tertiary);
            color: var(--bg-deep);
            border-radius: 0.25rem;
            font-size: 0.75rem;
            font-weight: 600;
            min-width: 40px;
            text-align: center;
            margin-right: 0.75rem;
        }

        .tx-player .player-name {
            flex: 1;
            font-weight: 500;
        }

        .tx-player .player-team {
            color: var(--text-secondary);
            font-size: 0.85rem;
        }

        .tx-actions {
            margin-top: 1.5rem;
            padding-top: 1rem;
            border-top: 1px solid var(--border);
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .tx-summary {
            flex: 1;
            font-size: 0.9rem;
            color: var(--text-secondary);
        }

        /* Trade-specific styles */
        .trade-columns {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1.5rem;
            margin-bottom: 1rem;
        }

        @media (max-width: 768px) {
            .trade-columns {
                grid-template-columns: 1fr;
            }
        }

        .trade-column {
            background: var(--bg-deep);
            border-radius: 0.75rem;
            padding: 1rem;
        }

        .trade-column h4 {
            margin: 0 0 1rem 0;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border);
        }

        .trade-subsection {
            margin-bottom: 1rem;
        }

        .trade-subsection h5 {
            margin: 0 0 0.5rem 0;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .pick-list {
            display: grid;
            gap: 0.5rem;
            max-height: 300px;
            overflow-y: auto;
            padding: 0.25rem;
        }

        .tx-pick {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 0.25rem;
            padding: 0.5rem 0.75rem;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s ease;
        }

        .tx-pick:hover {
            border-color: var(--accent-tertiary);
        }

        .tx-pick.selected {
            background: rgba(68, 136, 255, 0.15);
            border-color: var(--accent-primary);
        }

        .tx-pick-label {
            font-weight: 500;
        }

        .tx-pick-condition {
            font-size: 0.75rem;
            color: var(--accent-warning, #f0a020);
            font-style: italic;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .tx-pick-condition::before {
            content: '';
        }

        /* Trade conditions editor */
        .trade-conditions-section {
            margin-top: 1.5rem;
            padding: 1rem;
            background: var(--bg-deep);
            border: 1px solid var(--border);
            border-radius: 0.75rem;
        }

        .trade-conditions-section h4 {
            margin: 0 0 0.5rem 0;
            font-size: 1rem;
        }

        .tx-description-inline {
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin: 0 0 1rem 0;
        }

        .trade-conditions-list {
            display: grid;
            gap: 0.75rem;
        }

        .trade-condition-item {
            display: flex;
            align-items: flex-start;
            gap: 0.75rem;
            padding: 0.75rem;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 0.5rem;
        }

        .trade-condition-label {
            flex-shrink: 0;
            font-weight: 500;
            min-width: 150px;
            padding-top: 0.25rem;
        }

        .trade-condition-label .item-type {
            font-size: 0.7rem;
            color: var(--text-secondary);
            text-transform: uppercase;
            display: block;
        }

        .trade-condition-input {
            flex: 1;
            padding: 0.5rem 0.75rem;
            background: var(--bg-deep);
            border: 1px solid var(--border);
            border-radius: 0.25rem;
            color: var(--text-primary);
            font-size: 0.85rem;
        }

        .trade-condition-input:focus {
            outline: none;
            border-color: var(--accent-primary);
        }

        .trade-condition-input::placeholder {
            color: var(--text-muted);
        }

        /* Pending trades */
        .pending-trades-list {
            display: grid;
            gap: 1rem;
        }

        .pending-trade-card {
            background: var(--bg-deep);
            border: 1px solid var(--border);
            border-radius: 0.75rem;
            padding: 1.25rem;
        }

        .pending-trade-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .pending-trade-teams {
            font-weight: 600;
            font-size: 1rem;
        }

        .pending-trade-date {
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        .pending-trade-details {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin-bottom: 1rem;
            font-size: 0.9rem;
        }

        .pending-trade-side h5 {
            margin: 0 0 0.5rem 0;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        .pending-trade-side ul {
            margin: 0;
            padding-left: 1.25rem;
        }

        .pending-trade-actions {
            display: flex;
            gap: 0.75rem;
            padding-top: 1rem;
            border-top: 1px solid var(--border);
        }

        .pending-trade-actions button {
            padding: 0.5rem 1rem;
            font-size: 0.85rem;
        }

        .pending-trade-condition {
            display: block;
            font-size: 0.75rem;
            color: var(--accent-warning, #f0a020);
            font-style: italic;
            margin-top: 0.15rem;
        }

        .accept-btn {
            background: var(--win);
            color: var(--bg-deep);
        }

        .reject-btn {
            background: var(--accent-secondary);
            color: white;
        }

        .pending-status-badge {
            display: inline-block;
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .pending-status-badge.pending {
            background: var(--tie);
            color: var(--bg-deep);
        }

        .pending-status-badge.accepted {
            background: var(--win);
            color: var(--bg-deep);
        }

        .pending-status-badge.rejected {
            background: var(--accent-secondary);
            color: white;
        }

        .no-pending-trades {
            text-align: center;
            padding: 2rem;
            color: var(--text-secondary);
        }

        /* Hall of Fame sub-navigation */
        .hof-subnav {
            display: flex;
            justify-content: center;
            gap: 0.5rem;
            margin-bottom: 2rem;
            flex-wrap: wrap;
        }

        .hof-subnav-btn {
            padding: 0.5rem 1.25rem;
            font-family: 'Outfit', sans-serif;
            font-weight: 500;
            font-size: 0.85rem;
            background: var(--bg-card);
            border: 1px solid var(--border);
            color: var(--text-secondary);
            border-radius: 2rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .hof-subnav-btn:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
            border-color: var(--accent-tertiary);
        }

        .hof-subnav-btn.active {
            background: var(--accent-tertiary);
            border-color: var(--accent-tertiary);
            color: var(--bg-deep);
            font-weight: 600;
        }

        .hof-subview {
            display: none;
        }

        .hof-subview.active {
            display: block;
        }

        /* Team subnav (reuses hof-subnav styles) */
        .team-subnav {
            display: flex;
            justify-content: center;
            gap: 0.5rem;
            margin-bottom: 1.5rem;
            flex-wrap: wrap;
        }

        .team-subnav-btn {
            padding: 0.5rem 1.25rem;
            font-family: 'Outfit', sans-serif;
            font-weight: 500;
            font-size: 0.85rem;
            background: var(--bg-card);
            border: 1px solid var(--border);
            color: var(--text-secondary);
            border-radius: 2rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .team-subnav-btn:hover {
            background: var(--bg-hover);
            color: var(--text-primary);
            border-color: var(--accent-tertiary);
        }

        .team-subnav-btn.active {
            background: var(--accent-tertiary);
            border-color: var(--accent-tertiary);
            color: var(--bg-deep);
            font-weight: 600;
        }

        .team-subview {
            display: none;
        }

        .team-subview.active {
            display: block;
        }

        /* Trade Block styles */
        .trade-block-content {
            padding: 1rem;
            max-width: 900px;
            margin: 0 auto;
        }

        .trade-block-empty {
            text-align: center;
            padding: 3rem;
            color: var(--text-muted);
        }

        .trade-block-empty-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
        }

        .trade-block-section {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 0.75rem;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
        }

        .trade-block-section-title {
            font-family: 'Bebas Neue', sans-serif;
            font-size: 1.2rem;
            letter-spacing: 0.05em;
            color: var(--text-primary);
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border);
        }

        .trade-block-section-title.seeking {
            color: var(--win);
        }

        .trade-block-section-title.trading {
            color: var(--accent-secondary);
        }

        .trade-block-positions {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .trade-block-position {
            display: inline-flex;
            align-items: center;
            padding: 0.4rem 0.8rem;
            background: var(--bg-hover);
            border: 1px solid var(--border);
            border-radius: 2rem;
            font-size: 0.85rem;
            font-weight: 500;
        }

        .trade-block-position.seeking {
            background: rgba(0, 255, 136, 0.1);
            border-color: rgba(0, 255, 136, 0.3);
            color: var(--win);
        }

        .trade-block-position.trading {
            background: rgba(255, 51, 102, 0.1);
            border-color: rgba(255, 51, 102, 0.3);
            color: var(--loss);
        }

        .trade-block-players {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .trade-block-player {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem 1rem;
            background: var(--bg-hover);
            border-radius: 0.5rem;
            border-left: 3px solid var(--accent-secondary);
        }

        .trade-block-player-pos {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            color: var(--text-muted);
            min-width: 2.5rem;
        }

        .trade-block-player-name {
            flex: 1;
            font-weight: 500;
        }

        .trade-block-notes {
            padding: 1rem;
            background: var(--bg-hover);
            border-radius: 0.5rem;
            font-size: 0.9rem;
            color: var(--text-secondary);
            font-style: italic;
        }

        .trade-block-no-items {
            color: var(--text-muted);
            font-size: 0.9rem;
            font-style: italic;
        }

        /* Manage Trade Block styles */
        .trade-block-editor {
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        .trade-block-editor-section {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            padding: 1.25rem;
        }

        .trade-block-editor-section h4 {
            margin-bottom: 1rem;
            font-size: 1rem;
            color: var(--text-primary);
        }

        .trade-block-checkboxes {
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
        }

        .trade-block-checkbox {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0.75rem;
            background: var(--bg-hover);
            border: 1px solid var(--border);
            border-radius: 0.35rem;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .trade-block-checkbox:hover {
            border-color: var(--accent-primary);
        }

        .trade-block-checkbox.selected {
            background: rgba(68, 136, 255, 0.2);
            border-color: var(--accent-primary);
        }

        .trade-block-checkbox input {
            accent-color: var(--accent-primary);
        }

        .trade-block-player-select {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            max-height: 300px;
            overflow-y: auto;
        }

        .trade-block-player-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.5rem 0.75rem;
            background: var(--bg-hover);
            border: 1px solid var(--border);
            border-radius: 0.35rem;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .trade-block-player-item:hover {
            border-color: var(--accent-secondary);
        }

        .trade-block-player-item.selected {
            background: rgba(255, 51, 102, 0.15);
            border-color: var(--accent-secondary);
        }

        .trade-block-player-item input {
            accent-color: var(--accent-secondary);
        }

        .trade-block-notes-input {
            width: 100%;
            min-height: 80px;
            padding: 0.75rem;
            background: var(--bg-hover);
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            color: var(--text-primary);
            font-family: 'Outfit', sans-serif;
            font-size: 0.9rem;
            resize: vertical;
        }

        .trade-block-notes-input:focus {
            outline: none;
            border-color: var(--accent-primary);
        }

        /* Team Hall of Fame styles */
        .team-hof-content {
            padding: 1rem;
        }

        .team-hof-section {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 1rem;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
        }

        .team-hof-section-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid var(--border);
        }

        .team-hof-record {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem 0;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }

        .team-hof-record:last-child {
            border-bottom: none;
        }

        .team-hof-record-label {
            color: var(--text-secondary);
        }

        .team-hof-record-value {
            color: var(--text-primary);
            font-weight: 500;
        }

        .team-banners-grid {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            justify-content: center;
        }

        .team-banner-item {
            max-width: 200px;
        }

        .team-banner-item img {
            width: 100%;
            border-radius: 0.5rem;
            border: 2px solid var(--accent);
        }

        /* Ring of Honor Styles */
        .ring-of-honor {
            background: linear-gradient(135deg, var(--bg-card) 0%, rgba(255, 215, 0, 0.05) 100%);
            border-color: rgba(255, 215, 0, 0.3);
        }

        .ring-of-honor-category {
            margin-bottom: 1.5rem;
        }

        .ring-of-honor-category:last-child {
            margin-bottom: 0;
        }

        .ring-of-honor-category-title {
            font-size: 1rem;
            font-weight: 600;
            color: var(--accent);
            margin-bottom: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .ring-of-honor-entry {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.4rem 0;
            color: var(--text-secondary);
        }

        .ring-of-honor-entry .ring-years {
            color: var(--text-muted);
            min-width: fit-content;
        }

        .ring-of-honor-entry .ring-name {
            color: var(--text-primary);
        }

        .ring-of-honor-entry .ring-stars {
            color: #ffd700;
            font-weight: bold;
            letter-spacing: 0.1em;
        }

        .no-banners {
            color: var(--text-muted);
            text-align: center;
            font-style: italic;
        }

        .playoff-finish-badge {
            display: inline-block;
            padding: 0.2rem 0.6rem;
            margin-left: 0.75rem;
            font-size: 0.75rem;
            font-weight: 600;
            border-radius: 1rem;
            background: var(--bg-hover);
            color: var(--text-secondary);
            vertical-align: middle;
        }

        .playoff-finish-badge.champion {
            background: linear-gradient(135deg, #ffd700, #ffb700);
            color: #1a1a1a;
        }

        .playoff-finish-badge.toilet-bowl {
            background: linear-gradient(135deg, #8B4513, #654321);
            color: #fff;
        }

        .playoff-finish-badge.jambo {
            background: linear-gradient(135deg, #4a90d9, #2c5aa0);
            color: #fff;
        }

        /* Taxi Squad Styles */
        .taxi-squad-section {
            margin-top: 2rem;
            padding: 1.5rem;
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 0.75rem;
        }

        .taxi-squad-section h3 {
            color: var(--accent-tertiary);
            margin-bottom: 0.5rem;
            font-size: 1.1rem;
        }

        .taxi-description {
            color: var(--text-muted);
            font-size: 0.85rem;
            margin-bottom: 1rem;
            font-style: italic;
        }

        .taxi-players {
            display: grid;
            gap: 0.5rem;
        }

        .taxi-player {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 0.5rem 0.75rem;
            background: var(--bg-hover);
            border-radius: 0.5rem;
            border-left: 3px solid var(--text-muted);
        }

        .taxi-table {
            margin-top: 1rem;
        }
        
        .taxi-table th,
        .taxi-table td {
            padding: 0.4rem 0.6rem;
        }
        
        .taxi-pos-cell {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            color: var(--accent-tertiary);
            font-weight: 600;
        }
        
        .roster-table tr.former-player,
        .taxi-table tr.former-player {
            opacity: 0.5;
        }
        
        .roster-table tr.former-player td,
        .taxi-table tr.former-player td {
            color: var(--text-muted);
        }
        
        .week-score.not-on-roster {
            color: var(--text-muted);
            font-style: italic;
        }
        
        .former-note {
            color: var(--text-muted);
            font-size: 0.8rem;
        }

        .taxi-position {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            font-weight: 600;
            color: var(--text-muted);
            background: var(--bg-deep);
            padding: 0.2rem 0.5rem;
            border-radius: 0.25rem;
            min-width: 3rem;
            text-align: center;
        }

        .taxi-name {
            flex: 1;
            color: var(--text-secondary);
        }

        .taxi-team {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            color: var(--text-muted);
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <img src="images/league_logo.png" alt="QPFL Logo" class="league-logo">
            <div class="logo">Quarantine Perennial Football League</div>
            <div class="season-selector" id="season-selector">
            <div class="season-badge" id="season-badge">2025 Season</div>
                <div class="season-dropdown" id="season-dropdown"></div>
            </div>
            <div class="updated" id="updated-time">Loading...</div>
        </header>

        <nav>
            <button class="nav-btn active" data-view="home">Home</button>
            <button class="nav-btn" data-view="matchups">Matchups</button>
            <button class="nav-btn" data-view="standings">Standings</button>
            <button class="nav-btn" data-view="teams">Teams</button>
            <button class="nav-btn" data-view="schedule">Schedule</button>
            <button class="nav-btn" data-view="stats">Stats Leaders</button>
            <button class="nav-btn" data-view="team-stats">Team Stats</button>
            <button class="nav-btn" data-view="hof">Hall of Fame</button>
            <button class="nav-btn" data-view="transactions">Transactions</button>
            <button class="nav-btn" data-view="drafts">Drafts</button>
            <button class="nav-btn" data-view="manage">Manage Rosters</button>
        </nav>

        <div id="home-view" class="view-container active">
            <div class="home-container">
                <!-- Header and Blurb - Always shown -->
                <div class="home-header">
                    <h1 class="home-title">Welcome to the QPFL</h1>
                    <p class="home-blurb">The Quarantine Perennial Football League was founded in 2020 during the COVID-19 pandemic. What started as a way to stay connected has evolved into a dynasty fantasy football league with 10 teams competing for dominance each season.</p>
                </div>

                <!-- Season Content - During weeks 1-17 -->
                <div id="home-season-content" class="home-section">
                    <div class="home-grid">
                        <div class="home-card">
                            <h2 class="home-card-title">This Week's Matchups</h2>
                            <div id="home-matchups" class="home-matchups"></div>
                        </div>
                        <div class="home-card">
                            <h2 class="home-card-title">Current Standings</h2>
                            <div id="home-standings" class="home-standings"></div>
                        </div>
                    </div>
                    <div class="home-card home-transactions-card">
                        <h2 class="home-card-title">Recent Transactions</h2>
                        <div id="home-transactions" class="home-transactions"></div>
                    </div>
                </div>

                <!-- Offseason Content - After week 17 -->
                <div id="home-offseason-content" class="home-section" style="display: none;">
                    <div class="home-champion-section">
                        <div class="home-banner-container" id="home-banner"></div>
                        <h2 class="home-champion-title" id="home-champion-name"></h2>
                    </div>
                    <div class="home-grid">
                        <div class="home-card">
                            <h2 class="home-card-title">Championship Game</h2>
                            <div id="home-championship" class="home-championship"></div>
                            <div id="home-champ-scorers" class="home-top-scorers"></div>
                        </div>
                        <div class="home-card">
                            <h2 class="home-card-title">Champion's Top Performers</h2>
                            <div id="home-season-scorers" class="home-top-scorers"></div>
                        </div>
                    </div>
                    <div class="home-grid">
                        <div class="home-card">
                            <h2 class="home-card-title">Final Standings</h2>
                            <div id="home-final-standings" class="home-standings"></div>
                        </div>
                        <div class="home-card">
                            <h2 class="home-card-title" id="home-draft-order-title">Draft Order</h2>
                            <div id="home-draft-order" class="home-draft-order"></div>
                        </div>
                    </div>
                    <div class="home-card home-transactions-card">
                        <h2 class="home-card-title">Recent Transactions</h2>
                        <div id="home-offseason-transactions" class="home-transactions"></div>
                    </div>
                </div>
            </div>
        </div>

        <div id="matchups-view" class="view-container">
            <div class="week-selector" id="week-selector"></div>
            <div class="matchups" id="matchups-container"></div>
        </div>

        <div id="standings-view" class="view-container">
            <table class="standings-table">
                <thead>
                    <tr>
                        <th>#</th>
                        <th>Team</th>
                        <th class="num">Rank Pts</th>
                        <th class="num">Record</th>
                        <th class="num">Top 5</th>
                        <th class="num">PF</th>
                        <th class="num">PA</th>
                    </tr>
                </thead>
                <tbody id="standings-body"></tbody>
            </table>
        </div>

        <div id="teams-view" class="view-container">
            <div class="team-selector" id="team-selector"></div>
            <div class="team-subnav">
                <button class="team-subnav-btn active" data-subview="roster">Roster</button>
                <button class="team-subnav-btn" data-subview="tradeblock">Trade Block</button>
                <button class="team-subnav-btn" data-subview="hof">Team Hall of Fame</button>
            </div>
            <div class="team-subview active" id="team-roster-subview">
            <div class="team-roster" id="team-roster-container"></div>
            </div>
            <div class="team-subview" id="team-tradeblock-subview">
                <div class="trade-block-content" id="team-tradeblock-container"></div>
            </div>
            <div class="team-subview" id="team-hof-subview">
                <div class="team-hof-content" id="team-hof-container"></div>
            </div>
        </div>

        <div id="schedule-view" class="view-container">
            <div class="schedule-grid" id="schedule-container"></div>
        </div>

        <div id="stats-view" class="view-container">
            <div class="page-title">Stats Leaders</div>
            <div class="stats-position-selector" id="stats-position-selector"></div>
            <div class="stats-leaders-container" id="stats-leaders-container"></div>
        </div>

        <div id="team-stats-view" class="view-container">
            <div class="page-title">Team Stats</div>
            <div class="team-stats-content" id="team-stats-container"></div>
        </div>

        <div id="hof-view" class="view-container">
            <div class="page-title">Hall of Fame</div>
            <div class="hof-subnav">
                <button class="hof-subnav-btn active" data-subview="records">Records</button>
                <button class="hof-subnav-btn" data-subview="banners">Banner Room</button>
                <button class="hof-subnav-btn" data-subview="constitution">Constitution</button>
            </div>
            <div class="hof-subview active" id="hof-records-subview">
                <div class="hof-content" id="hof-container"></div>
            </div>
            <div class="hof-subview" id="hof-banners-subview">
                <div class="banners-grid" id="banners-container"></div>
            </div>
            <div class="hof-subview" id="hof-constitution-subview">
                <div class="constitution-content" id="constitution-container"></div>
            </div>
        </div>

        <div id="transactions-view" class="view-container">
            <div class="page-title">Transaction Log</div>
            <div class="transactions-season-selector" id="transactions-season-selector"></div>
            <div class="transactions-content" id="transactions-container"></div>
        </div>

        <div id="drafts-view" class="view-container">
            <div class="page-title">Drafts</div>
            <div class="drafts-tabs" id="drafts-tabs"></div>
            <div class="drafts-content" id="drafts-container"></div>
        </div>

        <div id="manage-view" class="view-container">
            <div class="page-title">Manage Rosters</div>
            <div class="manage-container">
                <!-- Auth Section -->
                <div class="manage-auth" id="manage-auth">
                    <div class="auth-card">
                        <h3>Select Your Team</h3>
                        <select id="manage-team-select" class="lineup-select">
                            <option value="">-- Choose Team --</option>
                        </select>
                        <input type="password" id="manage-password" class="lineup-input" placeholder="Enter team password">
                        <button id="manage-login-btn" class="lineup-btn primary">Login</button>
                        <div id="manage-error" class="lineup-error"></div>
                    </div>
                </div>

                <!-- Transaction Tabs -->
                <div class="manage-panel" id="manage-panel" style="display: none;">
                    <div class="manage-header">
                        <h3 id="manage-team-name"></h3>
                        <button id="manage-logout-btn" class="lineup-btn secondary">â† Logout</button>
                    </div>
                    
                    <div class="transaction-tabs">
                        <button class="tx-tab active" data-tab="lineup">Set Lineup</button>
                        <button class="tx-tab" data-tab="taxi">Taxi Squad</button>
                        <button class="tx-tab" data-tab="fa">Free Agents</button>
                        <button class="tx-tab" data-tab="trade">Propose Trade</button>
                        <button class="tx-tab" data-tab="pending">Pending Trades</button>
                        <button class="tx-tab" data-tab="tradeblock">Trade Block</button>
                    </div>

                    <!-- Set Lineup Tab -->
                    <div class="tx-content active" id="tx-lineup">
                        <div class="tx-description">
                            <p>Set your starting lineup for each week. Select one player per position (two for RB and WR).</p>
                        </div>
                        
                        <!-- Team Name Change Section -->
                        <div class="tx-section team-name-section">
                            <h4>Team Name</h4>
                            <div class="team-name-editor">
                                <input type="text" id="new-team-name" class="lineup-input" placeholder="Enter new team name" maxlength="50">
                                <button id="change-team-name-btn" class="lineup-btn secondary">Update Name</button>
                            </div>
                            <div id="team-name-status" class="submit-status"></div>
                        </div>
                        
                        <div class="tx-section">
                            <h4>Select Week</h4>
                            <select id="lineup-week-select" class="lineup-select" style="margin-bottom: 1rem;">
                                <option value="">-- Select Week --</option>
                            </select>
                        </div>
                        <div class="lineup-editor" id="lineup-editor" style="display: none;">
                            <div class="editor-header">
                                <span id="editor-week-label" class="week-badge"></span>
                            </div>
                            <div class="lineup-instructions">
                                <p>Select <strong>one starter</strong> for each position slot. Click on a player to toggle their starting status.</p>
                            </div>
                            <div class="position-groups" id="position-groups"></div>
                            <div class="lineup-actions">
                                <div class="lineup-summary" id="lineup-summary"></div>
                                <div class="lineup-comment-section">
                                    <label for="lineup-comment">Add a comment (optional):</label>
                                    <textarea id="lineup-comment" class="lineup-comment" placeholder="e.g., Last minute switch due to injury report..." maxlength="500"></textarea>
                                </div>
                                <button id="lineup-submit-btn" class="lineup-btn primary large">Submit Lineup</button>
                            </div>
                            <div id="submit-status" class="submit-status"></div>
                        </div>
                    </div>

                    <!-- Taxi Activation Tab -->
                    <div class="tx-content" id="tx-taxi">
                        <div class="tx-description">
                            <p>Activate a player from your taxi squad to your active roster. You must release a player at the same position.</p>
                        </div>
                        <div class="tx-section">
                            <h4>Your Taxi Squad</h4>
                            <div id="taxi-players" class="player-list"></div>
                        </div>
                        <div class="tx-section" id="taxi-release-section" style="display: none;">
                            <h4>Select Player to Release</h4>
                            <div id="taxi-release-players" class="player-list"></div>
                        </div>
                        <div class="tx-actions" id="taxi-actions" style="display: none;">
                            <div class="tx-summary" id="taxi-summary"></div>
                            <div class="lineup-comment-section">
                                <label for="taxi-comment">Add a comment (optional):</label>
                                <textarea id="taxi-comment" class="lineup-comment" placeholder="e.g., Activating for playoff push..." maxlength="500"></textarea>
                            </div>
                            <button id="taxi-submit-btn" class="lineup-btn primary">Confirm Activation</button>
                        </div>
                        <div id="taxi-status" class="submit-status"></div>
                    </div>

                    <!-- FA Pool Tab -->
                    <div class="tx-content" id="tx-fa">
                        <div class="tx-description">
                            <p>Add a player from the free agent pool. You must release a player at the same position.</p>
                        </div>
                        <div class="tx-section">
                            <h4>Available Free Agents</h4>
                            <div id="fa-players" class="player-list"></div>
                        </div>
                        <div class="tx-section" id="fa-release-section" style="display: none;">
                            <h4>Select Player to Release</h4>
                            <div id="fa-release-players" class="player-list"></div>
                        </div>
                        <div class="tx-actions" id="fa-actions" style="display: none;">
                            <div class="tx-summary" id="fa-summary"></div>
                            <div class="lineup-comment-section">
                                <label for="fa-comment">Add a comment (optional):</label>
                                <textarea id="fa-comment" class="lineup-comment" placeholder="e.g., Streaming defense for this week..." maxlength="500"></textarea>
                            </div>
                            <button id="fa-submit-btn" class="lineup-btn primary">Confirm Pickup</button>
                        </div>
                        <div id="fa-status" class="submit-status"></div>
                    </div>

                    <!-- Trade Proposal Tab -->
                    <div class="tx-content" id="tx-trade">
                        <div class="tx-description">
                            <p>Propose a trade with another team. Both teams must approve for the trade to execute.</p>
                            <p class="deadline-warning" id="trade-deadline-warning"></p>
                        </div>
                        <div class="tx-section">
                            <h4>Trade Partner</h4>
                            <select id="trade-partner-select" class="lineup-select">
                                <option value="">-- Select Team --</option>
                            </select>
                        </div>
                        <div class="trade-columns">
                            <div class="trade-column">
                                <h4>You Give</h4>
                                <div class="trade-subsection">
                                    <h5>Players</h5>
                                    <div id="trade-give-players" class="player-list"></div>
                                </div>
                                <div class="trade-subsection">
                                    <h5>Draft Picks</h5>
                                    <div id="trade-give-picks" class="pick-list"></div>
                                </div>
                            </div>
                            <div class="trade-column">
                                <h4>You Receive</h4>
                                <div class="trade-subsection">
                                    <h5>Players</h5>
                                    <div id="trade-receive-players" class="player-list"></div>
                                </div>
                                <div class="trade-subsection">
                                    <h5>Draft Picks</h5>
                                    <div id="trade-receive-picks" class="pick-list"></div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Trade Conditions Section -->
                        <div class="trade-conditions-section" id="trade-conditions-section" style="display: none;">
                            <h4>Trade Conditions</h4>
                            <p class="tx-description-inline">Add conditions to specific items in this trade (e.g., "if player scores 10+ TDs" or "pick becomes 2nd rounder if team makes playoffs")</p>
                            <div id="trade-conditions-list" class="trade-conditions-list"></div>
                        </div>
                        
                        <div class="tx-actions">
                            <div class="lineup-comment-section">
                                <label for="trade-comment">Add a message to the trade (optional):</label>
                                <textarea id="trade-comment" class="lineup-comment" placeholder="e.g., I think this is fair because..." maxlength="500"></textarea>
                            </div>
                            <button id="trade-submit-btn" class="lineup-btn primary">Propose Trade</button>
                        </div>
                        <div id="trade-status" class="submit-status"></div>
                    </div>

                    <!-- Pending Trades Tab -->
                    <div class="tx-content" id="tx-pending">
                        <div class="tx-description">
                            <p>Trades waiting for your approval or pending with other teams.</p>
                        </div>
                        <div id="pending-trades" class="pending-trades-list"></div>
                        <div id="pending-status" class="submit-status"></div>
                    </div>

                    <!-- Trade Block Tab -->
                    <div class="tx-content" id="tx-tradeblock">
                        <div class="tx-description">
                            <p>Set your trade block to let other managers know what positions you're looking for and what players you're willing to trade.</p>
                </div>
                        <div class="trade-block-editor">
                            <div class="trade-block-editor-section">
                                <h4>Positions I'm Seeking</h4>
                                <div class="trade-block-checkboxes" id="seeking-positions">
                                    <label class="trade-block-checkbox">
                                        <input type="checkbox" value="QB"> QB
                                    </label>
                                    <label class="trade-block-checkbox">
                                        <input type="checkbox" value="RB"> RB
                                    </label>
                                    <label class="trade-block-checkbox">
                                        <input type="checkbox" value="WR"> WR
                                    </label>
                                    <label class="trade-block-checkbox">
                                        <input type="checkbox" value="TE"> TE
                                    </label>
                                    <label class="trade-block-checkbox">
                                        <input type="checkbox" value="K"> K
                                    </label>
                                    <label class="trade-block-checkbox">
                                        <input type="checkbox" value="D/ST"> D/ST
                                    </label>
                                    <label class="trade-block-checkbox">
                                        <input type="checkbox" value="HC"> HC
                                    </label>
                                    <label class="trade-block-checkbox">
                                        <input type="checkbox" value="OL"> OL
                                    </label>
                                    <label class="trade-block-checkbox">
                                        <input type="checkbox" value="Draft Picks"> Draft Picks
                                    </label>
                                </div>
                            </div>

                            <div class="trade-block-editor-section">
                                <h4>Positions I'm Trading Away</h4>
                                <div class="trade-block-checkboxes" id="trading-positions">
                                    <label class="trade-block-checkbox">
                                        <input type="checkbox" value="QB"> QB
                                    </label>
                                    <label class="trade-block-checkbox">
                                        <input type="checkbox" value="RB"> RB
                                    </label>
                                    <label class="trade-block-checkbox">
                                        <input type="checkbox" value="WR"> WR
                                    </label>
                                    <label class="trade-block-checkbox">
                                        <input type="checkbox" value="TE"> TE
                                    </label>
                                    <label class="trade-block-checkbox">
                                        <input type="checkbox" value="K"> K
                                    </label>
                                    <label class="trade-block-checkbox">
                                        <input type="checkbox" value="D/ST"> D/ST
                                    </label>
                                    <label class="trade-block-checkbox">
                                        <input type="checkbox" value="HC"> HC
                                    </label>
                                    <label class="trade-block-checkbox">
                                        <input type="checkbox" value="OL"> OL
                                    </label>
                                    <label class="trade-block-checkbox">
                                        <input type="checkbox" value="Draft Picks"> Draft Picks
                                    </label>
                                </div>
                            </div>

                            <div class="trade-block-editor-section">
                                <h4>Specific Players Available for Trade</h4>
                                <div class="trade-block-player-select" id="available-players"></div>
                            </div>

                            <div class="trade-block-editor-section">
                                <h4>Notes (optional)</h4>
                                <textarea id="tradeblock-notes" class="trade-block-notes-input" placeholder="e.g., Looking for young RBs, willing to move veterans for picks..."></textarea>
                            </div>

                            <div class="tx-actions">
                                <button id="tradeblock-submit-btn" class="lineup-btn primary">Save Trade Block</button>
                            </div>
                            <div id="tradeblock-status" class="submit-status"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        const CURRENT_SEASON = 2026;
        
        let data = null;
        let sharedData = null;  // Holds constitution, hall of fame, banners, transactions, drafts from current season
        let currentWeek = 1;
        let currentSeason = CURRENT_SEASON;
        let availableSeasons = [CURRENT_SEASON];  // Will be populated on load

        async function loadData(season = null) {
            if (season !== null) {
                currentSeason = season;
            }
            
            try {
                // Always load main data.json first for shared resources
                if (!sharedData) {
                    const mainResponse = await fetch(`data.json?t=${Date.now()}`, { cache: 'no-store' });
                    if (mainResponse.ok) {
                        sharedData = await mainResponse.json();
                        availableSeasons = await detectAvailableSeasons();
                    }
                }
                
                // Use data.json for current season, data_YEAR.json for historical
                if (currentSeason === CURRENT_SEASON) {
                    data = sharedData;
                } else {
                    const dataFile = `data_${currentSeason}.json`;
                    const response = await fetch(dataFile);
                    
                    if (!response.ok) {
                        throw new Error(`Season ${currentSeason} not available`);
                    }
                    
                data = await response.json();
                    
                    // Merge in shared data from main file
                    data.constitution = sharedData.constitution;
                    data.hall_of_fame = sharedData.hall_of_fame;
                    data.banners = sharedData.banners;
                    data.transactions = sharedData.transactions;
                    data.drafts = sharedData.drafts;
                }
                
                // Cap currentWeek at 17 for display (offseason shows week 17)
                // During pre-season (week 0), use week 1 for display purposes
                currentWeek = data.current_week === 0 ? 1 : Math.min(data.current_week, 17);
                
                // Normalize nested data structures (from new export format with updated_at wrappers)
                if (data.standings && typeof data.standings === 'object' && !Array.isArray(data.standings)) {
                    data.standings = data.standings.standings || [];
                }
                if (data.banners && typeof data.banners === 'object' && !Array.isArray(data.banners)) {
                    data.banners = data.banners.banners || [];
                }
                if (data.constitution && typeof data.constitution === 'object' && data.constitution.articles) {
                    data.constitution = data.constitution.articles || [];
                }
                // draft_picks is now a flat array - no normalization needed
                // Format: [{ year, round, draft_type, original_team, current_owner, previous_owners }, ...]
                
                // Transactions are now in flat format with season field - no merging needed
                // data.transactions already contains all historical and recent transactions
                
                // Sort standings properly: rank_points (desc), wins (desc), points_for (desc)
                if (Array.isArray(data.standings)) {
                    data.standings.sort((a, b) => 
                        (b.rank_points || 0) - (a.rank_points || 0) ||
                        (b.wins || 0) - (a.wins || 0) ||
                        (b.points_for || 0) - (a.points_for || 0)
                    );
                }
                
                render();
                renderSeasonSelector();
            } catch (error) {
                console.error('Error loading data:', error);
                document.getElementById('updated-time').textContent = `Error loading ${currentSeason} season`;
                
                // If historical season failed to load, fall back to current
                if (currentSeason !== CURRENT_SEASON) {
                    console.log('Falling back to current season...');
                    loadData(CURRENT_SEASON);
                }
            }
        }
        
        async function detectAvailableSeasons() {
            // Start with current season
            const seasons = [CURRENT_SEASON];
            
            // Check for historical seasons (2024 down to 2020)
            for (let year = CURRENT_SEASON - 1; year >= 2020; year--) {
                try {
                    const response = await fetch(`data_${year}.json?t=${Date.now()}`, { method: 'HEAD', cache: 'no-store' });
                    if (response.ok) {
                        seasons.push(year);
                    }
                } catch (e) {
                    // Season not available, skip
                }
            }
            
            return seasons;
        }
        
        function renderSeasonSelector() {
            const dropdown = document.getElementById('season-dropdown');
            const badge = document.getElementById('season-badge');
            const selector = document.getElementById('season-selector');
            
            badge.textContent = `${currentSeason} Season`;
            
            // Build dropdown options
            dropdown.innerHTML = availableSeasons.map(season => `
                <button class="season-option ${season === currentSeason ? 'active' : ''}" 
                        data-season="${season}">${season}</button>
            `).join('');
            
            // Add click handlers
            dropdown.querySelectorAll('.season-option').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const season = parseInt(btn.dataset.season);
                    if (season !== currentSeason) {
                        loadData(season);
                    }
                    selector.classList.remove('open');
                });
            });
            
            // Toggle dropdown on badge click
            badge.onclick = (e) => {
                e.stopPropagation();
                selector.classList.toggle('open');
            };
            
            // Close dropdown when clicking outside
            document.addEventListener('click', () => {
                selector.classList.remove('open');
            });
        }

        function formatDate(isoString) {
            const date = new Date(isoString);
            return date.toLocaleString('en-US', {
                weekday: 'short',
                month: 'short',
                day: 'numeric',
                hour: 'numeric',
                minute: '2-digit',
                timeZoneName: 'short'
            });
        }
        
        // Format transaction message to match: "Added QB Name (TEAM) from FA Pool, released QB Name (TEAM)"
        function formatTransactionMessage(tx) {
            const txType = tx.type || '';
            const added = tx.added || tx.activated;
            const released = tx.released;
            
            // Extract player details
            const getPlayerStr = (player) => {
                if (!player) return '';
                if (typeof player === 'object') {
                    const pos = player.position || '';
                    const name = player.name || '';
                    const team = player.nfl_team || '';
                    return (pos && team) ? `${pos} ${name} (${team})` : name;
                }
                return player;
            };
            
            // Format pick string for display (e.g., "2027-R3-CWR" -> "CWR 2027 3rd")
            const formatPick = (pick) => {
                if (typeof pick === 'string') {
                    const parts = pick.split('-');
                    if (parts.length >= 3) {
                        const year = parts[0];
                        const round = parts[1].replace('R', '');
                        const team = parts[2];
                        const suffix = round === '1' ? 'st' : round === '2' ? 'nd' : round === '3' ? 'rd' : 'th';
                        return `${team} ${year} ${round}${suffix}`;
                    }
                }
                return pick;
            };
            
            const addedStr = getPlayerStr(added);
            const releasedStr = getPlayerStr(released);
            
            let msg = '';
            if (txType === 'trade') {
                // New trade format with proposer/partner
                const proposer = tx.proposer || 'Unknown';
                const partner = tx.partner || 'Unknown';
                const gives = tx.proposer_gives || {};
                const receives = tx.proposer_receives || {};
                
                const proposerName = data.teams?.find(t => t.abbrev === proposer)?.name || proposer;
                const partnerName = data.teams?.find(t => t.abbrev === partner)?.name || partner;
                
                const givesPlayers = (gives.players || []).map(p => getPlayerStr(p)).filter(Boolean);
                const givesPicks = (gives.picks || []).map(p => formatPick(p));
                const receivesPlayers = (receives.players || []).map(p => getPlayerStr(p)).filter(Boolean);
                const receivesPicks = (receives.picks || []).map(p => formatPick(p));
                
                const givesAll = [...givesPlayers, ...givesPicks];
                const receivesAll = [...receivesPlayers, ...receivesPicks];
                
                msg = `${proposerName} sends ${givesAll.join(', ') || 'nothing'} â†’ ${partnerName} sends ${receivesAll.join(', ') || 'nothing'}`;
            } else if (txType === 'fa_activation') {
                msg = addedStr ? `Added ${addedStr} from FA Pool` : '';
                if (releasedStr) msg += `, released ${releasedStr}`;
            } else if (txType === 'taxi_activation') {
                msg = addedStr ? `Activated ${addedStr}` : '';
                if (releasedStr) msg += `, released ${releasedStr}`;
            } else {
                // Generic format for other types
                msg = txType.replace(/_/g, ' ');
                if (addedStr) msg += `: Added ${addedStr}`;
                if (releasedStr) msg += `, released ${releasedStr}`;
            }
            
            return msg;
        }

        function render() {
            document.getElementById('season-badge').textContent = `${data.season} Season`;
            document.getElementById('updated-time').textContent = `Last updated: ${formatDate(data.updated_at)}`;
            
            const isHistorical = data.is_historical || data.season !== CURRENT_SEASON;
            
            // Update nav buttons for historical seasons
            const manageBtn = document.querySelector('.nav-btn[data-view="manage"]');
            const scheduleBtn = document.querySelector('.nav-btn[data-view="schedule"]');
            
            if (manageBtn) {
                manageBtn.style.display = isHistorical ? 'none' : '';
            }
            if (scheduleBtn) {
                scheduleBtn.style.display = isHistorical ? 'none' : '';
            }
            
            // If viewing hidden section and switching to historical, go back to matchups
            if (isHistorical) {
                const activeView = document.querySelector('.nav-btn.active');
                if (activeView && (activeView.dataset.view === 'manage' || activeView.dataset.view === 'schedule')) {
                    document.querySelector('.nav-btn[data-view="matchups"]').click();
                }
            }
            
            renderWeekSelector();
            renderHome();
            renderMatchups();
            renderStandings();
            renderTeams();
            renderSchedule();
            renderStatsLeaders();
            renderTeamStats();
            renderBanners();
            renderHallOfFame();
            renderTransactions();
            renderDrafts();
            renderConstitution();
        }

        function renderWeekSelector() {
            const container = document.getElementById('week-selector');
            
            // Collect all weeks from both weeks data and schedule (for playoffs)
            const allWeeks = new Set(data.weeks.map(w => w.week));
            if (data.schedule) {
                data.schedule.forEach(w => allWeeks.add(w.week));
            }
            const weekNumbers = Array.from(allWeeks).sort((a, b) => a - b);
            
            container.innerHTML = `
                <span class="week-label">WEEK</span>
                ${weekNumbers.map(weekNum => {
                    const scheduleWeek = data.schedule?.find(w => w.week === weekNum);
                    const isPlayoffs = scheduleWeek?.is_playoffs;
                    const playoffClass = isPlayoffs ? 'playoff' : '';
                    return `
                        <button class="week-btn ${weekNum === currentWeek ? 'active' : ''} ${playoffClass}" 
                                data-week="${weekNum}">${weekNum}</button>
                    `;
                }).join('')}
            `;

            container.querySelectorAll('.week-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    currentWeek = parseInt(btn.dataset.week);
                    renderWeekSelector();
                    renderMatchups();
                });
            });
        }

        function renderHome() {
            // Offseason: current_week is 0 (pre-season), 18+ (post-season), or explicit flag
            const isOffseason = data.is_offseason || data.current_week === 0 || data.current_week >= 17 || data.is_historical;
            
            const seasonContent = document.getElementById('home-season-content');
            const offseasonContent = document.getElementById('home-offseason-content');
            
            if (isOffseason) {
                seasonContent.style.display = 'none';
                offseasonContent.style.display = 'block';
                renderHomeOffseason();
            } else {
                seasonContent.style.display = 'block';
                offseasonContent.style.display = 'none';
                renderHomeSeason();
            }
        }

        function renderHomeSeason() {
            // Render current week matchups
            const matchupsContainer = document.getElementById('home-matchups');
            const weekData = data.weeks.find(w => w.week === currentWeek);
            
            if (weekData && weekData.matchups) {
                matchupsContainer.innerHTML = weekData.matchups.map(m => {
                    const t1 = m.team1 || {};
                    const t2 = m.team2 || {};
                    const t1Name = typeof t1 === 'string' ? t1 : (t1.team_name || t1.abbrev || 'TBD');
                    const t2Name = typeof t2 === 'string' ? t2 : (t2.team_name || t2.abbrev || 'TBD');
                    const t1Score = typeof t1 === 'object' ? (t1.total_score ?? '-') : '-';
                    const t2Score = typeof t2 === 'object' ? (t2.total_score ?? '-') : '-';
                    
                    const t1Winner = t1Score > t2Score ? 'winner' : (t1Score < t2Score ? 'loser' : '');
                    const t2Winner = t2Score > t1Score ? 'winner' : (t2Score < t1Score ? 'loser' : '');
                    
                    return `
                        <div class="home-matchup">
                            <div class="home-matchup-team ${t1Winner}">
                                <span>${t1Name}</span>
                                <span class="home-matchup-score">${t1Score}</span>
                            </div>
                            <span class="home-matchup-vs">vs</span>
                            <div class="home-matchup-team ${t2Winner}" style="justify-content: flex-end; text-align: right;">
                                <span class="home-matchup-score">${t2Score}</span>
                                <span>${t2Name}</span>
                            </div>
                        </div>
                    `;
                }).join('');
            } else {
                matchupsContainer.innerHTML = '<p style="color: var(--text-muted);">No matchups available</p>';
            }
            
            // Render standings
            const standingsContainer = document.getElementById('home-standings');
            standingsContainer.innerHTML = data.standings.map((team, i) => `
                <div class="home-standing-row">
                    <span class="home-standing-rank">${i + 1}.</span>
                    <span class="home-standing-team">${team.team_name || team.abbrev}</span>
                    <span class="home-standing-rp">${team.rank_points?.toFixed(1) || 0} RP</span>
                    <span class="home-standing-record">${team.wins || 0}-${team.losses || 0}</span>
                </div>
            `).join('');
            
            // Render recent transactions (capped at 5)
            renderHomeTransactions();
        }

        function renderHomeTransactions() {
            const container = document.getElementById('home-transactions');
            const transactions = data.transactions || [];
            
            if (transactions.length === 0) {
                container.innerHTML = '<p style="color: var(--text-muted);">No recent transactions</p>';
                return;
            }
            
            // Transactions are in flat format, newest first - take first 5
            const recent = transactions.slice(0, 5);
            
            container.innerHTML = recent.map(tx => {
                const isNewTrade = tx.type === 'trade' && tx.proposer && tx.partner;
                let teamName, type, details;
                
                if (isNewTrade) {
                    // New trade format with proposer/partner
                    const proposerName = data.teams?.find(t => t.abbrev === tx.proposer)?.name || tx.proposer;
                    const partnerName = data.teams?.find(t => t.abbrev === tx.partner)?.name || tx.partner;
                    teamName = `${proposerName} â†” ${partnerName}`;
                    type = 'Trade';
                    
                    // Build trade details
                    const getPlayerStr = (p) => typeof p === 'object' ? `${p.position || ''} ${p.name || ''}`.trim() : p;
                    const gives = tx.proposer_gives || {};
                    const receives = tx.proposer_receives || {};
                    const givesItems = [...(gives.players || []).map(getPlayerStr), ...(gives.picks || [])];
                    const receivesItems = [...(receives.players || []).map(getPlayerStr), ...(receives.picks || [])];
                    details = `${tx.proposer}: ${givesItems.join(', ') || 'nothing'} â†’ ${tx.partner}: ${receivesItems.join(', ') || 'nothing'}`;
                } else {
                    teamName = data.teams?.find(t => t.abbrev === tx.team)?.name || tx.team;
                    type = tx.type?.replace(/_/g, ' ') || 'Transaction';
                    const added = tx.added || tx.activated;
                    const released = tx.released;
                    
                    if (tx.message) {
                        details = tx.message;
                    } else if (added) {
                        const addedName = typeof added === 'object' ? added.name : added;
                        const addedPos = typeof added === 'object' ? added.position : '';
                        const addedTeam = typeof added === 'object' ? added.nfl_team : '';
                        details = addedPos && addedTeam ? `${addedPos} ${addedName} (${addedTeam})` : addedName;
                        if (released) {
                            const relName = typeof released === 'object' ? released.name : released;
                            details += `, released ${relName}`;
                        }
                    } else {
                        details = '';
                    }
                }
                
                // Format date from timestamp
                let dateStr = '';
                if (tx.timestamp) {
                    const d = new Date(tx.timestamp);
                    dateStr = `${d.getMonth()+1}/${d.getDate()}/${d.getFullYear()}`;
                }
                
                return `
                    <div class="home-transaction">
                        <div class="home-transaction-header">
                            <span class="home-transaction-team">${teamName}</span>
                            <span class="home-transaction-date">${dateStr}</span>
                        </div>
                        <div class="home-transaction-text">${type}: ${details}</div>
                    </div>
                `;
            }).join('');
        }

        function renderHomeOffseason() {
            // For offseason, show PREVIOUS season's championship
            // Use previous_season data if available (2026 showing 2025 champ)
            const prevSeason = data.previous_season;
            const displaySeason = prevSeason ? prevSeason.season : data.season;
            const displayWeeks = prevSeason ? prevSeason.weeks : data.weeks;
            const displayStandings = prevSeason ? prevSeason.standings : data.standings;
            const displayTeams = prevSeason ? prevSeason.teams : data.teams;
            
            // Render champion banner (previous season's banner)
            const bannerContainer = document.getElementById('home-banner');
            const bannersData = data.banners || {};
            const banners = bannersData.banners || bannersData || [];
            const currentBanner = Array.isArray(banners) ? banners.find(b => b.includes(`${displaySeason}`)) : null;
            
            if (currentBanner) {
                bannerContainer.innerHTML = `<img src="images/banners/${currentBanner}" alt="${displaySeason} Champion Banner">`;
            }
            
            // Render championship matchup from week 17 and determine champion from game result
            const week17 = displayWeeks.find(w => w && w.week === 17);
            const championshipContainer = document.getElementById('home-championship');
            const champScorersContainer = document.getElementById('home-champ-scorers');
            const championName = document.getElementById('home-champion-name');
            
            let champion = null;
            let championAbbrev = null;
            
            if (week17 && week17.matchups && week17.matchups.length > 0) {
                // First matchup is the championship - winner is the champion
                const champ = week17.matchups[0];
                const t1 = champ.team1 || {};
                const t2 = champ.team2 || {};
                const t1Name = typeof t1 === 'object' ? (t1.team_name || t1.abbrev) : t1;
                const t2Name = typeof t2 === 'object' ? (t2.team_name || t2.abbrev) : t2;
                const t1Score = typeof t1 === 'object' ? t1.total_score : 0;
                const t2Score = typeof t2 === 'object' ? t2.total_score : 0;
                
                const t1Winner = t1Score > t2Score;
                const t2Winner = t2Score > t1Score;
                
                championshipContainer.innerHTML = `
                    <div class="home-championship-matchup">
                        <div class="home-championship-team">
                            <div class="home-championship-name ${t1Winner ? 'winner' : ''}">${t1Name}</div>
                            <div class="home-championship-score ${t1Winner ? 'winner' : ''}">${t1Score}</div>
                        </div>
                        <span class="home-championship-vs">vs</span>
                        <div class="home-championship-team">
                            <div class="home-championship-name ${t2Winner ? 'winner' : ''}">${t2Name}</div>
                            <div class="home-championship-score ${t2Winner ? 'winner' : ''}">${t2Score}</div>
                        </div>
                    </div>
                    <span class="home-championship-label">CHAMPIONSHIP</span>
                `;
                
                // Determine champion from game result
                const winnerTeam = t1Winner ? t1 : t2;
                champion = winnerTeam;
                championAbbrev = winnerTeam.abbrev;
                
                // Set champion name
                if (championName) {
                    championName.textContent = `${displaySeason} Champion: ${winnerTeam.team_name || winnerTeam.name || winnerTeam.abbrev}`;
                }
                
                // Get top 3 scorers from championship game for the winner
                if (winnerTeam.roster) {
                    const starters = winnerTeam.roster.filter(p => p.starter);
                    const topScorers = starters.sort((a, b) => (b.score || 0) - (a.score || 0)).slice(0, 3);
                    
                    champScorersContainer.innerHTML = `
                        <div class="home-scorers-title">Championship Top Scorers</div>
                        ${topScorers.map(p => `
                            <div class="home-scorer-row">
                                <span class="home-scorer-pos">${p.position}</span>
                                <span class="home-scorer-name">${p.name}</span>
                                <span class="home-scorer-pts">${(p.score || 0).toFixed(1)}</span>
                            </div>
                        `).join('')}
                    `;
                }
            }
            
            // Calculate season-long top scorers for champion
            const seasonScorersContainer = document.getElementById('home-season-scorers');
            if (championAbbrev) {
                const playerTotals = {};
                
                for (const week of displayWeeks) {
                    for (const matchup of (week.matchups || [])) {
                        for (const teamKey of ['team1', 'team2']) {
                            const team = matchup[teamKey];
                            if (team?.abbrev === championAbbrev && team.roster) {
                                for (const player of team.roster) {
                                    if (player.starter && player.name) {
                                        if (!playerTotals[player.name]) {
                                            playerTotals[player.name] = {
                                                name: player.name,
                                                position: player.position,
                                                total: 0,
                                                games: 0
                                            };
                                        }
                                        playerTotals[player.name].total += (player.score || 0);
                                        playerTotals[player.name].games += 1;
                                    }
                                }
                            }
                        }
                    }
                }
                
                const topSeasonScorers = Object.values(playerTotals)
                    .sort((a, b) => b.total - a.total)
                    .slice(0, 3);
                
                seasonScorersContainer.innerHTML = `
                    <div class="home-scorers-title">Season Leaders</div>
                    ${topSeasonScorers.map(p => `
                        <div class="home-scorer-row">
                            <span class="home-scorer-pos">${p.position}</span>
                            <span class="home-scorer-name">${p.name}</span>
                            <span class="home-scorer-pts">${p.total.toFixed(1)} pts</span>
                        </div>
                    `).join('')}
                `;
            }
            
            // Render final standings
            const standingsContainer = document.getElementById('home-final-standings');
            standingsContainer.innerHTML = (displayStandings || []).map((team, i) => `
                <div class="home-standing-row">
                    <span class="home-standing-rank">${i + 1}.</span>
                    <span class="home-standing-team">${team.team_name || team.abbrev}</span>
                    <span class="home-standing-rp">${team.rank_points?.toFixed(1) || 0} RP</span>
                    <span class="home-standing-record">${team.wins || 0}-${team.losses || 0}</span>
                </div>
            `).join('');
            
            // Render draft order (reverse of standings for next season)
            const draftOrderTitle = document.getElementById('home-draft-order-title');
            draftOrderTitle.textContent = `${displaySeason + 1} Draft Order`;
            
            const draftOrderContainer = document.getElementById('home-draft-order');
            const draftOrder = [...(displayStandings || [])].reverse();
            draftOrderContainer.innerHTML = draftOrder.map((team, i) => `
                <div class="home-draft-pick">
                    <span class="home-draft-pick-num">${i + 1}</span>
                    <span class="home-draft-pick-team">${team.team_name || team.abbrev}</span>
                </div>
            `).join('');
            
            // Render recent transactions
            renderHomeOffseasonTransactions();
        }
        
        function renderHomeOffseasonTransactions() {
            const container = document.getElementById('home-offseason-transactions');
            const transactions = data.transactions || [];
            
            if (transactions.length === 0) {
                container.innerHTML = '<div class="home-no-transactions">No recent transactions</div>';
                return;
            }
            
            // Transactions are newest-first, take first 5
            const recentTxns = transactions.slice(0, 5);
            
            container.innerHTML = recentTxns.map(tx => {
                const isNewTrade = tx.type === 'trade' && tx.proposer && tx.partner;
                let teamDisplay, type, details;
                
                if (isNewTrade) {
                    teamDisplay = `${tx.proposer} â†” ${tx.partner}`;
                    type = 'trade';
                    
                    // Build trade details
                    const getPlayerStr = (p) => typeof p === 'object' ? p.name : p;
                    const gives = tx.proposer_gives || {};
                    const receives = tx.proposer_receives || {};
                    const givesItems = [...(gives.players || []).map(getPlayerStr), ...(gives.picks || [])];
                    const receivesItems = [...(receives.players || []).map(getPlayerStr), ...(receives.picks || [])];
                    details = `<span class="tx-add">${tx.proposer} â†’ ${givesItems.join(', ')}</span> <span class="tx-drop">${tx.partner} â†’ ${receivesItems.join(', ')}</span>`;
                } else {
                    teamDisplay = tx.team;
                    type = tx.type?.replace(/_/g, ' ') || 'Transaction';
                    const added = tx.added || tx.activated;
                    const released = tx.released;
                    
                    if (tx.message) {
                        details = tx.message;
                    } else if (added) {
                        const addedName = typeof added === 'object' ? added.name : added;
                        details = `<span class="tx-add">+ ${addedName}</span>`;
                        if (released) {
                            const releasedName = typeof released === 'object' ? released.name : released;
                            details += ` <span class="tx-drop">- ${releasedName}</span>`;
                        }
                    } else {
                        details = '';
                    }
                }
                
                return `
                    <div class="home-transaction-item">
                        <div class="home-tx-header">
                            <span class="home-tx-team">${teamDisplay}</span>
                            <span class="home-tx-type">${type}</span>
                        </div>
                        <div class="home-tx-details">${details}</div>
                    </div>
                `;
            }).join('');
        }

        function renderMatchups() {
            const weekData = data.weeks.find(w => w.week === currentWeek);
            const scheduleWeek = data.schedule?.find(w => w.week === currentWeek);
            const container = document.getElementById('matchups-container');
            
            // If no week data exists, show the schedule matchups (for playoffs or upcoming weeks)
            if (!weekData || !weekData.matchups || weekData.matchups.length === 0) {
                if (scheduleWeek && scheduleWeek.matchups) {
                    const isPlayoffs = scheduleWeek.is_playoffs;
                    const playoffRound = scheduleWeek.playoff_round || '';
                    
                    // Group matchups by bracket for playoffs
                    const bracketLabels = {
                        'playoffs': 'ðŸ† Playoffs',
                        'championship': 'ðŸ† Championship',
                        'consolation_cup': 'ðŸ¥‰ Consolation Cup',
                        'mid_bowl': 'ðŸ¥£ Mid Bowl',
                        'sewer_series': 'ðŸš¿ Sewer Series',
                        'toilet_bowl': 'ðŸš½ Toilet Bowl',
                        'jamboree': 'ðŸŽª Jamboree'
                    };
                    
                    let matchupsHtml = '';
                    
                    if (isPlayoffs) {
                        // Group by bracket
                        const matchupsByBracket = {};
                        scheduleWeek.matchups.forEach(m => {
                            const bracket = m.bracket || 'other';
                            if (!matchupsByBracket[bracket]) matchupsByBracket[bracket] = [];
                            matchupsByBracket[bracket].push(m);
                        });
                        
                        // Helper to get team info and roster for upcoming matchups
                        const getTeamData = (abbrev) => {
                            // Get team info from standings or teams
                            const teamInfo = data.standings?.find(t => t.abbrev === abbrev) || 
                                           data.teams?.find(t => t.abbrev === abbrev) || 
                                           { abbrev, name: abbrev, owner: '' };
                            
                            // Check if there's lineup data for this week from JSON submissions
                            let roster = [];
                            let hasLineupData = false;
                            
                            // Check if lineup was submitted for this week
                            if (data.lineups?.[abbrev]) {
                                hasLineupData = true;
                            }
                            
                            // Get roster from rosters data (base roster) - exclude taxi players
                            const baseRoster = (data.rosters?.[abbrev] || []).filter(p => !p.taxi);
                            
                            if (hasLineupData && baseRoster.length > 0) {
                                // If lineup was submitted, mark starters based on lineup data
                                const lineupStarters = data.lineups[abbrev];
                                roster = baseRoster.map(p => {
                                    const posStarters = lineupStarters[p.position] || [];
                                    const isStarter = posStarters.some(s => 
                                        s.toLowerCase() === p.name.toLowerCase() ||
                                        p.name.toLowerCase().includes(s.toLowerCase())
                                    );
                                    return { ...p, starter: isStarter };
                                });
                            } else {
                                // No lineup data - show all players as bench (not starters)
                                roster = baseRoster.map(p => ({ ...p, starter: false }));
                            }
                            
                            return { ...teamInfo, roster };
                        };
                        
                        let matchupIdx = 0;
                        const bracketOrder = ['playoffs', 'championship', 'consolation_cup', 'mid_bowl', 'sewer_series', 'toilet_bowl', 'jamboree', 'other'];
                        matchupsHtml = bracketOrder
                            .filter(bracket => matchupsByBracket[bracket])
                            .map(bracket => {
                                const label = bracketLabels[bracket] || '';
                                return `
                                    ${label ? `<div class="playoff-bracket-header ${bracket}">${label}</div>` : ''}
                                    ${matchupsByBracket[bracket].map(m => {
                                        const seed1 = m.seed1 ? `<span class="matchup-seed">#${m.seed1}</span>` : '';
                                        const seed2 = m.seed2 ? `<span class="matchup-seed">#${m.seed2}</span>` : '';
                                        const t1 = getTeamData(m.team1);
                                        const t2 = getTeamData(m.team2);
                                        const idx = matchupIdx++;
                                        const hasRosters = t1.roster.length > 0 && t2.roster.length > 0;
                                        
                                        return `
                                            <div class="matchup-card pending playoff bracket-${bracket}">
                                                <div class="matchup-header">
                                                    <div class="team">
                                                        ${seed1}
                                                        <div class="team-name">${t1.name || m.team1}</div>
                                                        <div class="team-owner">${t1.owner || ''}</div>
                                                    </div>
                                                    <div class="vs-container">
                                                        <span class="vs-text">vs</span>
                                                    </div>
                                                    <div class="team right">
                                                        <div class="team-name">${t2.name || m.team2}</div>
                                                        <div class="team-owner">${t2.owner || ''}</div>
                                                        ${seed2}
                                                    </div>
                                                </div>
                                                ${hasRosters ? `
                                                    <button class="expand-btn" data-matchup="pending-${idx}">Show Rosters â–¼</button>
                                                    <div class="roster-panel" id="roster-pending-${idx}">
                                                        <div class="roster-grid">
                                                            <div class="roster-column">
                                                                <h4>${t1.abbrev}</h4>
                                                                ${renderRoster(t1.roster, currentWeek)}
                                                            </div>
                                                            <div class="roster-column">
                                                                <h4>${t2.abbrev}</h4>
                                                                ${renderRoster(t2.roster, currentWeek)}
                                                            </div>
                                                        </div>
                                                    </div>
                                                ` : ''}
                                            </div>
                                        `;
                                    }).join('')}
                                `;
                            }).join('');
                    } else {
                        matchupsHtml = scheduleWeek.matchups.map(m => `
                            <div class="matchup-card pending">
                                <div class="matchup-header">
                                    <div class="team">
                                        <div class="team-name">${m.team1}</div>
                                    </div>
                                    <div class="vs-container">
                                        <span class="vs-text">vs</span>
                                    </div>
                                    <div class="team right">
                                        <div class="team-name">${m.team2}</div>
                                    </div>
                                </div>
                            </div>
                        `).join('');
                    }
                    
                    const headerText = isPlayoffs 
                        ? `<span class="playoff-round-badge">${playoffRound}</span> Scores not yet available`
                        : `Scores not yet available for Week ${currentWeek}`;
                    
                    container.innerHTML = `
                        <div class="no-scores-message ${isPlayoffs ? 'playoffs' : ''}">
                            <p>${headerText}</p>
                        </div>
                        ${matchupsHtml}
                    `;
                    
                    // Add expand/collapse functionality for pending matchups
                    container.querySelectorAll('.expand-btn').forEach(btn => {
                        btn.addEventListener('click', () => {
                            const panel = document.getElementById(`roster-${btn.dataset.matchup}`);
                            if (panel) {
                                const isExpanded = panel.classList.toggle('expanded');
                                btn.textContent = isExpanded ? 'Hide Rosters â–²' : 'Show Rosters â–¼';
                            }
                        });
                    });
                } else if (data.is_offseason) {
                    // Offseason - schedule not yet available
                    container.innerHTML = `
                        <div class="no-scores-message offseason">
                            <p>ðŸˆ The ${currentSeason} schedule has not been released yet</p>
                            <p class="offseason-subtitle">Matchups will be available once the regular season begins</p>
                        </div>
                    `;
                } else {
                    container.innerHTML = '<div class="no-scores-message"><p>Matchups not available for Week ' + currentWeek + '</p></div>';
                }
                return;
            }
            
            // Check if this is a playoff week and get bracket info
            const isPlayoffWeek = scheduleWeek?.is_playoffs;
            
            // Special handling for 2020 Jamboree - show scoreboard instead of matchups
            const hasJamboree = data.jamboree && weekData.matchups.some(m => m.bracket === 'jamboree');
            
            // Separate jamboree matchups from regular matchups
            const regularMatchups = hasJamboree 
                ? weekData.matchups.filter(m => m.bracket !== 'jamboree')
                : weekData.matchups;
            const jamboreeMatchups = hasJamboree 
                ? weekData.matchups.filter(m => m.bracket === 'jamboree')
                : [];
            
            // Build jamboree scoreboard HTML
            let jamboreeHtml = '';
            if (hasJamboree && jamboreeMatchups.length > 0) {
                // Collect all jamboree teams and their scores for this week
                const jamboreeTeams = [];
                jamboreeMatchups.forEach(m => {
                    jamboreeTeams.push({
                        name: m.team1.name,
                        abbrev: m.team1.abbrev,
                        owner: m.team1.owner,
                        week_score: m.team1.total_score
                    });
                    jamboreeTeams.push({
                        name: m.team2.name,
                        abbrev: m.team2.abbrev,
                        owner: m.team2.owner,
                        week_score: m.team2.total_score
                    });
                });
                
                // Get cumulative totals from jamboree data
                const jamboreeData = data.jamboree || [];
                jamboreeTeams.forEach(team => {
                    const jData = jamboreeData.find(j => j.abbrev === team.abbrev);
                    if (jData) {
                        team.week_15 = jData.week_15;
                        team.week_16 = jData.week_16;
                        team.total = currentWeek >= 16 ? jData.total : jData.week_15;
                    }
                });
                
                // Sort by total (or week_15 if only week 15)
                jamboreeTeams.sort((a, b) => (b.total || 0) - (a.total || 0));
                
                const isWeek16 = currentWeek >= 16;
                jamboreeHtml = `
                    <div class="playoff-bracket-header jamboree">ðŸŽª Jamboree</div>
                    <div class="jamboree-scoreboard">
                        <div class="jamboree-title">2-Week Total Points Contest${isWeek16 ? ' - Final' : ' - Week 1 of 2'}</div>
                        <table class="jamboree-table">
                            <thead>
                                <tr>
                                    <th class="jamboree-place"></th>
                                    <th>Team</th>
                                    <th>Owner</th>
                                    <th>Wk 15</th>
                                    ${isWeek16 ? '<th>Wk 16</th><th>Total</th>' : ''}
                                </tr>
                            </thead>
                            <tbody>
                                ${jamboreeTeams.map((t, i) => `
                                    <tr>
                                        <td class="jamboree-place ${i === 0 && isWeek16 ? 'first' : ''}">${i === 0 && isWeek16 ? 'ðŸ†' : (i + 1)}</td>
                                        <td>${t.name}</td>
                                        <td>${t.owner}</td>
                                        <td>${(t.week_15 || 0).toFixed(0)}</td>
                                        ${isWeek16 ? `<td>${(t.week_16 || 0).toFixed(0)}</td><td class="total">${(t.total || 0).toFixed(0)}</td>` : ''}
                                    </tr>
                                `).join('')}
                            </tbody>
                        </table>
                    </div>
                `;
            }
            
            // Get week 16 mid bowl scores for cumulative display in week 17
            let week16MidBowlScores = {};
            if (currentWeek === 17) {
                const week16Data = data.weeks.find(w => w.week === 16);
                if (week16Data) {
                    const midBowlMatchup = week16Data.matchups.find(m => m.bracket === 'mid_bowl');
                    if (midBowlMatchup) {
                        week16MidBowlScores[midBowlMatchup.team1.abbrev] = midBowlMatchup.team1.total_score;
                        week16MidBowlScores[midBowlMatchup.team2.abbrev] = midBowlMatchup.team2.total_score;
                    }
                }
            }
            
            const matchupsHtml = regularMatchups.map((matchup, idx) => {
                const t1 = matchup.team1;
                const t2 = matchup.team2;
                
                // Find the bracket for this matchup
                // First check if bracket is directly on the matchup (historical seasons)
                // Then fall back to looking in the schedule data
                let bracketClass = '';
                let isMidBowl = false;
                if (matchup.bracket) {
                    bracketClass = `bracket-${matchup.bracket}`;
                    isMidBowl = matchup.bracket === 'mid_bowl';
                } else if (isPlayoffWeek && scheduleWeek?.matchups) {
                    // Try exact matchup first
                    let scheduleMatchup = scheduleWeek.matchups.find(m => 
                        (m.team1 === t1.abbrev && m.team2 === t2.abbrev) ||
                        (m.team1 === t2.abbrev && m.team2 === t1.abbrev)
                    );
                    
                    // If no exact match, find which bracket team1 is in
                    if (!scheduleMatchup) {
                        scheduleMatchup = scheduleWeek.matchups.find(m => 
                            m.team1 === t1.abbrev || m.team2 === t1.abbrev
                        );
                    }
                    
                    if (scheduleMatchup?.bracket) {
                        bracketClass = `bracket-${scheduleMatchup.bracket}`;
                        isMidBowl = scheduleMatchup.bracket === 'mid_bowl';
                    }
                }
                
                // Calculate scores - for Mid Bowl in week 17, show cumulative
                let t1Score = t1.total_score;
                let t2Score = t2.total_score;
                let midBowlSubtitle = '';
                
                if (isMidBowl) {
                    if (currentWeek === 17 && week16MidBowlScores[t1.abbrev] !== undefined) {
                        const t1Week16 = week16MidBowlScores[t1.abbrev] || 0;
                        const t2Week16 = week16MidBowlScores[t2.abbrev] || 0;
                        const t1Week17 = t1.total_score;
                        const t2Week17 = t2.total_score;
                        t1Score = t1Week16 + t1Week17;
                        t2Score = t2Week16 + t2Week17;
                        midBowlSubtitle = `
                            <div class="mid-bowl-breakdown">
                                <span>${t1.abbrev}: ${t1Week16.toFixed(0)} + ${t1Week17.toFixed(0)} = ${t1Score.toFixed(0)}</span>
                                <span>${t2.abbrev}: ${t2Week16.toFixed(0)} + ${t2Week17.toFixed(0)} = ${t2Score.toFixed(0)}</span>
                            </div>
                        `;
                    } else if (currentWeek === 16) {
                        midBowlSubtitle = '<div class="mid-bowl-note">Week 1 of 2</div>';
                    }
                }
                
                const t1Winning = t1Score > t2Score;
                const t2Winning = t2Score > t1Score;

                return `
                    <div class="matchup-card ${bracketClass}">
                        <div class="matchup-header">
                            <div class="team">
                                <div class="team-name">${t1.name}</div>
                                <div class="team-owner">${t1.owner}</div>
                            </div>
                            <div class="vs-container">
                                <div class="score-display">
                                    <span class="score ${t1Winning ? 'winning' : 'losing'}">${t1Score.toFixed(0)}</span>
                                    <span class="score-divider">â€”</span>
                                    <span class="score ${t2Winning ? 'winning' : 'losing'}">${t2Score.toFixed(0)}</span>
                                </div>
                                ${midBowlSubtitle}
                            </div>
                            <div class="team right">
                                <div class="team-name">${t2.name}</div>
                                <div class="team-owner">${t2.owner}</div>
                            </div>
                        </div>
                        <button class="expand-btn" data-matchup="${idx}">Show Rosters â–¼</button>
                        <div class="roster-panel" id="roster-${idx}">
                            <div class="roster-grid">
                                <div class="roster-column">
                                    <h4>${t1.abbrev}</h4>
                                    ${renderRoster(t1.roster, currentWeek)}
                                </div>
                                <div class="roster-column">
                                    <h4>${t2.abbrev}</h4>
                                    ${renderRoster(t2.roster, currentWeek)}
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
            
            // Combine regular matchups with jamboree scoreboard
            container.innerHTML = matchupsHtml + jamboreeHtml;

            // Add expand/collapse functionality
            container.querySelectorAll('.expand-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const panel = document.getElementById(`roster-${btn.dataset.matchup}`);
                    const isExpanded = panel.classList.toggle('expanded');
                    btn.textContent = isExpanded ? 'Hide Rosters â–²' : 'Show Rosters â–¼';
                });
            });
        }

        function getPlayerStatus(player, weekNum) {
            // Get game time for this player's team
            const weekKey = String(weekNum);
            const gameTimes = data.game_times && data.game_times[weekKey];
            
            if (!gameTimes) return { status: 'unknown', label: '' };
            
            // Normalize team codes (some sources use different abbreviations)
            const teamAliases = {
                'LAR': 'LA',   // Rams
                'JAC': 'JAX', // Jaguars
                'WSH': 'WAS', // Commanders
            };
            
            let playerTeam = player.nfl_team;
            // Try the original team code first, then the alias
            let gameTime = gameTimes[playerTeam];
            if (!gameTime && teamAliases[playerTeam]) {
                gameTime = gameTimes[teamAliases[playerTeam]];
            }
            // Also try reverse lookup (if game_times uses LAR but player has LA)
            if (!gameTime) {
                const reverseAliases = { 'LA': 'LAR', 'JAX': 'JAC', 'WAS': 'WSH' };
                if (reverseAliases[playerTeam]) {
                    gameTime = gameTimes[reverseAliases[playerTeam]];
                }
            }
            
            // No game time = BYE week
            if (!gameTime) {
                return { status: 'bye', label: 'BYE' };
            }
            
            const kickoff = new Date(gameTime);
            const now = new Date();
            
            // Game hasn't started yet - show game time
            if (now < kickoff) {
                // Format: "Mon 8:15p" or "Sun 1:00p"
                const days = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
                const dayName = days[kickoff.getDay()];
                let hours = kickoff.getHours();
                const minutes = kickoff.getMinutes();
                const ampm = hours >= 12 ? 'p' : 'a';
                hours = hours % 12 || 12;
                const timeStr = minutes === 0 
                    ? `${hours}${ampm}`
                    : `${hours}:${String(minutes).padStart(2, '0')}${ampm}`;
                
                // Determine color class based on game day/time
                let colorClass = 'game-time-default';
                const dayOfWeek = kickoff.getDay();
                const hourOfDay = kickoff.getHours();
                
                if (dayOfWeek === 4) { // Thursday
                    colorClass = 'game-time-thursday';
                } else if (dayOfWeek === 5 || dayOfWeek === 6) { // Friday/Saturday
                    colorClass = 'game-time-frisat';
                } else                 if (dayOfWeek === 0) { // Sunday
                    if (hourOfDay < 12) { // Before noon = morning games (10am-11:59am PT / 1pm ET)
                        colorClass = 'game-time-sun-morning';
                    } else if (hourOfDay < 17) { // Noon to 5pm = afternoon games (12pm-4:59pm PT / 4pm ET)
                        colorClass = 'game-time-sun-afternoon';
                    } else { // 5 PM+ = night (5pm+ PT / 8pm ET SNF)
                        colorClass = 'game-time-sun-night';
                    }
                } else if (dayOfWeek === 1) { // Monday
                    colorClass = 'game-time-monday';
                }
                
                return { status: 'not-played', label: `${dayName} ${timeStr}`, colorClass };
            }
            
            // Game has started or finished - show actual score
            return { status: 'played', label: '' };
        }

        // Render roster from rosters data (for upcoming weeks without scores)
        function renderRosterFromData(roster) {
            if (!roster || roster.length === 0) return '<p>No roster data</p>';
            
            const posOrder = ['QB', 'RB', 'WR', 'TE', 'K', 'D/ST', 'HC', 'OL'];
            const sorted = [...roster].sort((a, b) => {
                return posOrder.indexOf(a.position) - posOrder.indexOf(b.position);
            });
            
            return sorted.map(p => `
                <div class="player-row">
                    <div class="player-info">
                        <span class="position-tag">${p.position}</span>
                        <span class="player-name">${p.name}</span>
                        <span class="player-team">${p.nfl_team}</span>
                    </div>
                </div>
            `).join('');
        }

        function renderRoster(roster, weekNum) {
            // Use current week if not specified
            const week = weekNum || data.current_week;
            
            // Sort: starters first by position order, then bench
            const posOrder = ['QB', 'RB', 'WR', 'TE', 'K', 'D/ST', 'HC', 'OL'];
            const sorted = [...roster].sort((a, b) => {
                if (a.starter !== b.starter) return b.starter - a.starter;
                return posOrder.indexOf(a.position) - posOrder.indexOf(b.position);
            });

            return sorted.map(p => {
                const status = getPlayerStatus(p, week);
                let scoreDisplay;
                
                if (status.status === 'bye') {
                    scoreDisplay = `<span class="player-status bye">BYE</span>`;
                } else if (status.status === 'not-played') {
                    const colorClass = status.colorClass || '';
                    scoreDisplay = `<span class="player-status not-played ${colorClass}">${status.label}</span>`;
                } else {
                    const score = p.score ?? 0;
                    scoreDisplay = `<span class="player-score">${score.toFixed(0)}</span>`;
                }
                
                return `
                <div class="player-row ${p.starter ? '' : 'bench'}">
                    <div class="player-info">
                        <span class="position-tag">${p.position}</span>
                        <span class="player-name">${p.name}</span>
                        <span class="player-team">${p.nfl_team}</span>
                    </div>
                        ${scoreDisplay}
                </div>
                `;
            }).join('');
        }

        function renderStandings() {
            const tbody = document.getElementById('standings-body');
            const totalTeams = data.standings.length;
            
            tbody.innerHTML = data.standings.map((team, idx) => {
                const rank = idx + 1;
                const isPlayoffs = rank <= 4;
                const isToiletBowl = rank > totalTeams - 4;
                const rankClass = isPlayoffs ? 'playoffs' : (isToiletBowl ? 'toilet-bowl' : '');
                const label = isPlayoffs ? '<span class="playoff-label playoffs">Playoffs</span>' : 
                              (isToiletBowl ? '<span class="playoff-label toilet">Toilet Bowl</span>' : '');
                
                return `
                    <tr>
                        <td class="rank ${rankClass}">${rank}</td>
                        <td>
                            <div class="team-name">${team.name}<span class="team-code">${team.abbrev}</span>${label}</div>
                            <div class="team-owner">${team.owner}</div>
                        </td>
                        <td class="num rank-points">${(team.rank_points ?? 0).toFixed(1)}</td>
                        <td class="num record">${team.wins ?? 0}-${team.losses ?? 0}${team.ties ? `-${team.ties}` : ''}</td>
                        <td class="num top-half">${team.top_half || 0}</td>
                        <td class="num points-for">${(team.points_for ?? 0).toFixed(1)}</td>
                        <td class="num points-against">${(team.points_against ?? 0).toFixed(1)}</td>
                    </tr>
                `;
            }).join('');
        }

        function renderSchedule() {
            if (!data.schedule) return;
            
            // Build a lookup for week scores from the weeks data
            const weekScores = {};
            if (data.weeks) {
                data.weeks.forEach(week => {
                    if (week.has_scores) {
                        weekScores[week.week] = {};
                        week.matchups.forEach(matchup => {
                            // Calculate total from starter scores
                            const team1Total = matchup.team1.roster
                                .filter(p => p.starter)
                                .reduce((sum, p) => sum + p.score, 0);
                            const team2Total = matchup.team2.roster
                                .filter(p => p.starter)
                                .reduce((sum, p) => sum + p.score, 0);
                            weekScores[week.week][matchup.team1.abbrev] = team1Total;
                            weekScores[week.week][matchup.team2.abbrev] = team2Total;
                        });
                    }
                });
            }
            
            const container = document.getElementById('schedule-container');
            container.innerHTML = data.schedule.map(week => {
                const isCurrent = week.week === data.current_week;
                const hasScores = weekScores[week.week];
                const isCompleted = hasScores !== undefined;
                const isRivalry = week.is_rivalry;
                const isPlayoffs = week.is_playoffs;
                
                const cardClasses = [
                    'schedule-week',
                    isRivalry ? 'rivalry' : '',
                    isPlayoffs ? 'playoffs' : '',
                    isCurrent ? 'current' : '',
                    isCompleted ? 'completed' : ''
                ].filter(Boolean).join(' ');
                
                const badge = isCurrent ? '<span class="schedule-week-badge current">Current</span>' :
                              (isCompleted ? '<span class="schedule-week-badge completed">Done</span>' : '');
                
                let weekTitle = isRivalry ? `Rivalry Week` : `Week ${week.week}`;
                if (isPlayoffs) {
                    weekTitle = week.playoff_round || `Playoffs Week ${week.week}`;
                }
                const titleClass = isRivalry ? 'rivalry' : (isPlayoffs ? 'playoffs' : '');
                
                // Group playoff matchups by bracket
                const matchupsByBracket = {};
                if (isPlayoffs) {
                    week.matchups.forEach(m => {
                        const bracket = m.bracket || 'other';
                        if (!matchupsByBracket[bracket]) {
                            matchupsByBracket[bracket] = [];
                        }
                        matchupsByBracket[bracket].push(m);
                    });
                }
                
                const bracketLabels = {
                    'playoffs': 'ðŸ† Playoffs',
                    'championship': 'ðŸ† Championship',
                    'consolation_cup': 'ðŸ¥‰ Consolation Cup',
                    'mid_bowl': 'ðŸ¥£ Mid Bowl',
                    'sewer_series': 'ðŸš¿ Sewer Series',
                    'toilet_bowl': 'ðŸš½ Toilet Bowl',
                    'jamboree': 'ðŸŽª Jamboree'
                };
                
                const renderMatchup = (m) => {
                    const team1 = m.team1;
                    const team2 = m.team2;
                    const score1 = hasScores ? weekScores[week.week]?.[team1] : undefined;
                    const score2 = hasScores ? weekScores[week.week]?.[team2] : undefined;
                    
                    // Show seed info for playoff matchups
                    const seed1 = m.seed1 ? `<span class="seed">#${m.seed1}</span>` : '';
                    const seed2 = m.seed2 ? `<span class="seed">#${m.seed2}</span>` : '';
                    
                    if (score1 !== undefined && score2 !== undefined) {
                        const winner1 = score1 > score2 ? 'winner' : (score1 < score2 ? 'loser' : '');
                        const winner2 = score2 > score1 ? 'winner' : (score2 < score1 ? 'loser' : '');
                        return `
                            <div class="schedule-matchup with-scores ${isPlayoffs ? 'playoff-matchup' : ''}">
                                ${seed1}<span class="schedule-team ${winner1}">${team1}</span>
                                <span class="schedule-score ${winner1}">${score1.toFixed(0)}</span>
                                <span class="schedule-vs">-</span>
                                <span class="schedule-score ${winner2}">${score2.toFixed(0)}</span>
                                <span class="schedule-team ${winner2}">${team2}</span>${seed2}
                            </div>
                        `;
                    }
                    return `
                        <div class="schedule-matchup ${isPlayoffs ? 'playoff-matchup' : ''}">
                            ${seed1}<span class="schedule-team">${team1}</span>
                            <span class="schedule-vs">vs</span>
                            <span class="schedule-team">${team2}</span>${seed2}
                        </div>
                    `;
                };
                
                // Render regular season week
                if (!isPlayoffs) {
                    return `
                        <div class="${cardClasses}">
                            <div class="schedule-week-header">
                                <span class="schedule-week-title ${titleClass}">${weekTitle}</span>
                                ${badge}
                            </div>
                            ${week.matchups.map(renderMatchup).join('')}
                        </div>
                    `;
                }
                
                // Render playoff week with brackets
                const bracketOrder = ['playoffs', 'championship', 'consolation_cup', 'mid_bowl', 'sewer_series', 'toilet_bowl', 'jamboree', 'other'];
                
                // Check if this is the final week of a Jamboree (2020 week 16)
                const hasJamboree = matchupsByBracket['jamboree'] && data.jamboree && week.week === 16;
                
                const bracketHtml = bracketOrder
                    .filter(bracket => matchupsByBracket[bracket])
                    .map(bracket => {
                        // For Jamboree, show the scoreboard instead of matchups in week 16
                        if (bracket === 'jamboree' && hasJamboree) {
                            return `
                                <div class="bracket-label ${bracket}">${bracketLabels[bracket]}</div>
                                <div class="jamboree-scoreboard">
                                    <div class="jamboree-title">2-Week Total Points Contest</div>
                                    <table class="jamboree-table">
                                        <thead>
                                            <tr>
                                                <th class="jamboree-place"></th>
                                                <th>Team</th>
                                                <th>Owner</th>
                                                <th>Wk 15</th>
                                                <th>Wk 16</th>
                                                <th>Total</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            ${data.jamboree.map(t => `
                                                <tr>
                                                    <td class="jamboree-place ${t.place === 1 ? 'first' : ''}">${t.place === 1 ? 'ðŸ†' : t.place}</td>
                                                    <td>${t.name}</td>
                                                    <td>${t.owner}</td>
                                                    <td>${(t.week_15 ?? 0).toFixed(0)}</td>
                                                    <td>${(t.week_16 ?? 0).toFixed(0)}</td>
                                                    <td class="total">${(t.total ?? 0).toFixed(0)}</td>
                                                </tr>
                                            `).join('')}
                                        </tbody>
                                    </table>
                                </div>
                            `;
                        }
                        // Skip Jamboree matchups in week 15 (they're shown in week 16 as scoreboard)
                        if (bracket === 'jamboree' && week.week === 15 && data.jamboree) {
                            return `
                                <div class="bracket-label ${bracket}">${bracketLabels[bracket]}</div>
                                <div class="jamboree-scoreboard">
                                    <div class="jamboree-title">2-Week Total Points Contest</div>
                                    <p style="text-align: center; color: var(--text-muted);">Week 1 of 2 - Final standings after Week 16</p>
                                </div>
                            `;
                        }
                        const label = bracketLabels[bracket] || '';
                        return `
                            ${label ? `<div class="bracket-label ${bracket}">${label}</div>` : ''}
                            ${matchupsByBracket[bracket].map(renderMatchup).join('')}
                        `;
                    }).join('');
                
                return `
                    <div class="${cardClasses}">
                        <div class="schedule-week-header">
                            <span class="schedule-week-title ${titleClass}">${weekTitle}</span>
                            ${badge}
                        </div>
                        ${bracketHtml}
                    </div>
                `;
            }).join('');
        }

        let currentTeam = null;

        function renderTeams() {
            // Get teams from standings, or fall back to data.teams during offseason
            let teams = data.standings;
            if (!teams || teams.length === 0) {
                // During offseason, use data.teams instead
                teams = data.teams || [];
            }
            if (!teams || teams.length === 0) return;
            
            // Default to first team if none selected
            if (!currentTeam) currentTeam = teams[0].abbrev;
            
            // Render team selector buttons
            const selectorContainer = document.getElementById('team-selector');
            selectorContainer.innerHTML = teams.map(team => `
                <button class="team-btn ${team.abbrev === currentTeam ? 'active' : ''}" 
                        data-team="${team.abbrev}">${team.abbrev}</button>
            `).join('');
            
            // Add click handlers
            selectorContainer.querySelectorAll('.team-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    currentTeam = btn.dataset.team;
                    // Reset to Roster tab when switching teams
                    document.querySelectorAll('.team-subnav-btn').forEach(b => b.classList.remove('active'));
                    document.querySelector('.team-subnav-btn[data-subview="roster"]')?.classList.add('active');
                    document.querySelectorAll('.team-subview').forEach(v => v.classList.remove('active'));
                    document.getElementById('team-roster-subview')?.classList.add('active');
                    renderTeams();
                });
            });
            
            // Find team info
            const teamInfo = teams.find(t => t.abbrev === currentTeam);
            if (!teamInfo) return;
            
            // Get all weeks with scores
            const weeksWithScores = (data.weeks || []).filter(w => w.has_scores);
            
            // Build player data across all weeks
            const playerMap = new Map(); // player key -> {name, team, position, weeks: {weekNum: {score, starter}}}
            
            weeksWithScores.forEach(week => {
                // Find this team in the week's matchups
                let teamData = null;
                for (const matchup of week.matchups) {
                    if (matchup.team1.abbrev === currentTeam) {
                        teamData = matchup.team1;
                        break;
                    }
                    if (matchup.team2.abbrev === currentTeam) {
                        teamData = matchup.team2;
                        break;
                    }
                }
                if (!teamData || !teamData.roster) return;
                
                teamData.roster.forEach(player => {
                    const key = `${player.position}-${player.name}`;
                    if (!playerMap.has(key)) {
                        playerMap.set(key, {
                            name: player.name,
                            nfl_team: player.nfl_team,
                            position: player.position,
                            weeks: {}
                        });
                    }
                    playerMap.get(key).weeks[week.week] = {
                        score: player.score,
                        starter: player.starter
                    };
                });
            });
            
            // Get final roster player names (to identify former players)
            // For past seasons, use the last week's roster; for current season, use data.rosters
            const finalRosterNames = new Set();
            if (currentSeason === CURRENT_SEASON && data.rosters && data.rosters[currentTeam]) {
                // Current season: use the live roster
                data.rosters[currentTeam].forEach(p => finalRosterNames.add(p.name.toLowerCase()));
                
                // Also add any players from the current roster who aren't in matchup history yet
                // (e.g., recently activated players who haven't had a scored week)
                data.rosters[currentTeam].forEach(player => {
                    if (player.taxi) return; // Skip taxi squad players
                    const key = `${player.position}-${player.name}`;
                    if (!playerMap.has(key)) {
                        playerMap.set(key, {
                            name: player.name,
                            nfl_team: player.nfl_team,
                            position: player.position,
                            weeks: {},
                            isNewlyActivated: true // Flag to indicate no history yet
                        });
                    }
                });
            } else if (weeksWithScores.length > 0) {
                // Past season: use the roster from the last week of the season
                const lastWeek = weeksWithScores[weeksWithScores.length - 1];
                const lastWeekMatchup = lastWeek.matchups?.find(m => 
                    m.team1.abbrev === currentTeam || m.team2.abbrev === currentTeam
                );
                if (lastWeekMatchup) {
                    const teamData = lastWeekMatchup.team1.abbrev === currentTeam 
                        ? lastWeekMatchup.team1 : lastWeekMatchup.team2;
                    teamData.roster?.forEach(p => finalRosterNames.add(p.name.toLowerCase()));
                }
            }
            
            // Group by position
            const positions = ['QB', 'RB', 'WR', 'TE', 'K', 'D/ST', 'HC', 'OL'];
            const playersByPosition = {};
            positions.forEach(pos => playersByPosition[pos] = []);
            
            playerMap.forEach((player, key) => {
                if (playersByPosition[player.position]) {
                    // Check if player finished the season on the roster
                    player.isOnCurrentRoster = finalRosterNames.has(player.name.toLowerCase());
                    playersByPosition[player.position].push(player);
                }
            });
            
            // Sort each position: current roster first, then former players (maintain original order within each group)
            positions.forEach(pos => {
                // Use stable sort - only move former players to bottom, don't reorder within groups
                const current = playersByPosition[pos].filter(p => p.isOnCurrentRoster);
                const former = playersByPosition[pos].filter(p => !p.isOnCurrentRoster);
                playersByPosition[pos] = [...current, ...former];
            });
            
            // Build a global lookup of player scores across all teams for each week
            // This lets us show scores for players who were on other teams
            const globalPlayerScores = {}; // {weekNum: {playerName: {score, nfl_team}}}
            weeksWithScores.forEach(week => {
                globalPlayerScores[week.week] = {};
                for (const matchup of week.matchups) {
                    [matchup.team1, matchup.team2].forEach(team => {
                        if (team && team.roster) {
                            team.roster.forEach(p => {
                                globalPlayerScores[week.week][p.name.toLowerCase()] = {
                                    score: p.score,
                                    nfl_team: p.nfl_team
                                };
                            });
                        }
                        if (team && team.taxi_squad) {
                            team.taxi_squad.forEach(p => {
                                globalPlayerScores[week.week][p.name.toLowerCase()] = {
                                    score: p.score || 0,
                                    nfl_team: p.nfl_team
                                };
                            });
                        }
                    });
                }
            });
            
            // Build table
            const weekHeaders = weeksWithScores.map(w => 
                `<th class="week-col">W${w.week}</th>`
            ).join('');
            
            let tableRows = '';
            const weekTotals = {};
            weeksWithScores.forEach(w => weekTotals[w.week] = 0);
            
            positions.forEach(pos => {
                const players = playersByPosition[pos];
                if (players.length === 0) return;
                
                // Position header row
                tableRows += `<tr class="position-group"><td colspan="${weeksWithScores.length + 4}">${pos}</td></tr>`;
                
                players.forEach(player => {
                    let rosterTotal = 0;  // Points scored while on this roster
                    let fullTotal = 0;    // All points including when on other teams
                    
                    const weekScores = weeksWithScores.map(w => {
                        const weekData = player.weeks[w.week];
                        const status = getPlayerStatus({ nfl_team: player.nfl_team }, w.week);
                        
                        if (weekData) {
                            // Player was on this roster this week
                        const cls = weekData.starter ? 'starter' : 'bench';
                        if (weekData.starter) weekTotals[w.week] += weekData.score;
                            rosterTotal += weekData.score;
                            fullTotal += weekData.score;
                            
                            if (status.status === 'bye') {
                                return `<td class="week-score ${cls}"><span class="player-status bye">BYE</span></td>`;
                            } else if (status.status === 'not-played' && weekData.score === 0) {
                                const colorClass = status.colorClass || '';
                                return `<td class="week-score ${cls}"><span class="player-status not-played ${colorClass}">${status.label}</span></td>`;
                            }
                        return `<td class="week-score ${cls}">${weekData.score.toFixed(0)}</td>`;
                        } else {
                            // Player wasn't on this roster - check if they have a score elsewhere
                            const globalScore = globalPlayerScores[w.week]?.[player.name.toLowerCase()];
                            if (globalScore && globalScore.score !== undefined) {
                                fullTotal += globalScore.score;
                                if (status.status === 'bye') {
                                    return `<td class="week-score not-on-roster"><span class="player-status bye">(BYE)</span></td>`;
                                }
                                return `<td class="week-score not-on-roster">(${(globalScore.score ?? 0).toFixed(0)})</td>`;
                            }
                            return '<td class="week-score not-on-roster">-</td>';
                        }
                    }).join('');
                    
                    const rowClass = player.isOnCurrentRoster ? '' : 'former-player';
                    const nameDisplay = player.isOnCurrentRoster ? player.name : `${player.name} *`;
                    
                    // Show roster total, and full total in parentheses if different
                    const totalDisplay = rosterTotal === fullTotal 
                        ? `${rosterTotal.toFixed(0)}`
                        : `${rosterTotal.toFixed(0)} (${fullTotal.toFixed(0)})`;
                    
                    tableRows += `
                        <tr class="${rowClass}">
                            <td class="player-name">${nameDisplay}</td>
                            <td class="player-team">${player.nfl_team}</td>
                            ${weekScores}
                            <td class="week-score season-total">${totalDisplay}</td>
                        </tr>
                    `;
                });
            });
            
            // Total row
            const totalScores = weeksWithScores.map(w => 
                `<td class="week-score">${weekTotals[w.week].toFixed(0)}</td>`
            ).join('');
            const starterSeasonTotal = Object.values(weekTotals).reduce((a, b) => a + b, 0);
            tableRows += `
                <tr class="total-row">
                    <td colspan="2"><strong>TOTAL</strong></td>
                    ${totalScores}
                    <td class="week-score">${starterSeasonTotal.toFixed(0)}</td>
                </tr>
            `;
            
            // Build taxi squad section with weekly scores - collect ALL taxi players from all weeks
            let taxiHtml = '';
            const taxiPlayerMap = new Map(); // player key -> {name, nfl_team, position, weeks: {weekNum: score}}
            
            // Get current taxi squad from most recent week (to identify who's still on squad)
            const mostRecentWeek = weeksWithScores[weeksWithScores.length - 1];
            const currentTaxiNames = new Set();
            if (mostRecentWeek) {
                for (const matchup of mostRecentWeek.matchups) {
                    const team = matchup.team1.abbrev === currentTeam ? matchup.team1 : 
                                (matchup.team2.abbrev === currentTeam ? matchup.team2 : null);
                    if (team && team.taxi_squad) {
                        team.taxi_squad.forEach(tp => currentTaxiNames.add(tp.name));
                    }
                }
            }
            
            // Collect ALL taxi players from ALL weeks
            weeksWithScores.forEach(weekData => {
                for (const matchup of weekData.matchups) {
                    const team = matchup.team1.abbrev === currentTeam ? matchup.team1 : 
                                (matchup.team2.abbrev === currentTeam ? matchup.team2 : null);
                    if (team && team.taxi_squad) {
                        team.taxi_squad.forEach(tp => {
                            const key = `${tp.position}-${tp.name}`;
                            if (!taxiPlayerMap.has(key)) {
                                taxiPlayerMap.set(key, {
                                    name: tp.name,
                                    nfl_team: tp.nfl_team,
                                    position: tp.position,
                                    weeks: {}
                                });
                            }
                            taxiPlayerMap.get(key).weeks[weekData.week] = tp.score || 0;
                        });
                    }
                }
            });
            
            if (taxiPlayerMap.size > 0) {
                // Sort taxi players: current squad first, then former players
                const taxiPlayers = Array.from(taxiPlayerMap.values());
                taxiPlayers.sort((a, b) => {
                    const aOnSquad = currentTaxiNames.has(a.name);
                    const bOnSquad = currentTaxiNames.has(b.name);
                    if (aOnSquad !== bOnSquad) return bOnSquad - aOnSquad;
                    return a.name.localeCompare(b.name);
                });
                
                // Build taxi table rows
                const taxiRows = taxiPlayers.map(playerData => {
                    const isOnCurrentSquad = currentTaxiNames.has(playerData.name);
                    let taxiTotal = 0;   // Points while on taxi squad
                    let fullTotal = 0;   // All points including when not on taxi
                    
                    const weekScores = weeksWithScores.map(w => {
                        const score = playerData.weeks[w.week];
                        const status = getPlayerStatus({ nfl_team: playerData.nfl_team }, w.week);
                        
                        if (score !== undefined) {
                            // Player was on taxi squad this week
                            taxiTotal += score;
                            fullTotal += score;
                            
                            if (status.status === 'bye') {
                                return `<td class="week-score"><span class="player-status bye">BYE</span></td>`;
                            } else if (status.status === 'not-played' && score === 0) {
                                const colorClass = status.colorClass || '';
                                return `<td class="week-score"><span class="player-status not-played ${colorClass}">${status.label}</span></td>`;
                            }
                            return `<td class="week-score">${score.toFixed(0)}</td>`;
                        } else {
                            // Player wasn't on taxi squad - check if they have a score elsewhere
                            const globalScore = globalPlayerScores[w.week]?.[playerData.name.toLowerCase()];
                            if (globalScore && globalScore.score !== undefined) {
                                fullTotal += globalScore.score;
                                if (status.status === 'bye') {
                                    return `<td class="week-score not-on-roster"><span class="player-status bye">(BYE)</span></td>`;
                                }
                                return `<td class="week-score not-on-roster">(${(globalScore.score ?? 0).toFixed(0)})</td>`;
                            }
                            return '<td class="week-score not-on-roster">-</td>';
                        }
                    }).join('');
                    
                    const rowClass = isOnCurrentSquad ? '' : 'former-player';
                    const nameDisplay = isOnCurrentSquad ? playerData.name : `${playerData.name} *`;
                    
                    // Show taxi total, and full total in parentheses if different
                    const totalDisplay = taxiTotal === fullTotal
                        ? `${taxiTotal.toFixed(0)}`
                        : `${taxiTotal.toFixed(0)} (${fullTotal.toFixed(0)})`;
                    
                    return `
                        <tr class="${rowClass}">
                            <td class="taxi-pos-cell">${playerData.position}</td>
                            <td class="player-name">${nameDisplay}</td>
                            <td class="player-team">${playerData.nfl_team}</td>
                            ${weekScores}
                            <td class="week-score season-total">${totalDisplay}</td>
                        </tr>
                    `;
                }).join('');
                
                    taxiHtml = `
                        <div class="taxi-squad-section">
                            <h3>Taxi Squad</h3>
                        <p class="taxi-description">Exclusive development players - cannot be started without promotion to active roster. <span class="former-note">* = no longer on taxi squad</span></p>
                        <div style="overflow-x: auto;">
                            <table class="roster-table taxi-table">
                                <thead>
                                    <tr>
                                        <th>Pos</th>
                                        <th>Player</th>
                                        <th>Team</th>
                                        ${weeksWithScores.map(w => `<th class="week-col">W${w.week}</th>`).join('')}
                                        <th class="week-col">Total</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${taxiRows}
                                </tbody>
                            </table>
                            </div>
                        </div>
                    `;
            }
            
            // Build draft picks section - new flat array format
            let picksHtml = '';
            if (data.draft_picks && Array.isArray(data.draft_picks)) {
                // Filter picks owned by current team
                const teamPicks = data.draft_picks.filter(p => p.current_owner === currentTeam);
                
                if (teamPicks.length > 0) {
                    const seasons = ['2026', '2027', '2028', '2029'];
                    const draftTypes = [
                        { key: 'offseason', label: 'Offseason Draft' },
                        { key: 'offseason_taxi', label: 'Offseason Taxi' },
                        { key: 'waiver', label: 'Waiver Draft' },
                        { key: 'waiver_taxi', label: 'Waiver Taxi' }
                    ];
                    
                    picksHtml = `
                        <div class="draft-picks-section">
                            <h3>Draft Picks</h3>
                            <div class="picks-grid">
                                ${seasons.map(season => {
                                    const seasonPicks = teamPicks.filter(p => p.year === season);
                                    if (seasonPicks.length === 0) return '';
                                    return `
                                        <div class="picks-season">
                                            <div class="picks-season-header">${season}</div>
                                            ${draftTypes.map(dt => {
                                                const picks = seasonPicks
                                                    .filter(p => p.draft_type === dt.key)
                                                    .sort((a, b) => a.round - b.round);
                                                if (picks.length === 0) return '';
                                                return `
                                                    <div class="picks-draft-type">
                                                        <div class="picks-type-label">${dt.label}</div>
                                                        <div class="picks-list">
                                                            ${picks.map(p => {
                                                                const isOwn = p.original_team === currentTeam;
                                                                const fromLabel = isOwn ? '' : ` <span class="pick-from">(${p.original_team})</span>`;
                                                                // Show "via" if previous_owners has more owners than just the original (intermediaries)
                                                                const prevOwners = p.previous_owners || [];
                                                                const lastPrevOwner = prevOwners.length > 0 ? prevOwners[prevOwners.length - 1] : null;
                                                                const hasVia = lastPrevOwner && lastPrevOwner !== p.original_team;
                                                                const viaLabel = hasVia ? ` <span class="pick-via">via ${lastPrevOwner}</span>` : '';
                                                                const conditionIcon = p.condition ? `<span class="pick-condition-icon" title="${p.condition.replace(/"/g, '&quot;')}">âš¡</span>` : '';
                                                                return `<span class="pick-item ${isOwn ? 'own' : 'acquired'}">R${p.round}${fromLabel}${viaLabel}${conditionIcon}</span>`;
                                                            }).join('')}
                                                        </div>
                                                    </div>
                                                `;
                                            }).join('')}
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        </div>
                    `;
                }
            }
            
            // Render
            const rosterContainer = document.getElementById('team-roster-container');
            rosterContainer.innerHTML = `
                <div class="team-header">
                    <h2>${teamInfo.name}</h2>
                    <div class="owner">${teamInfo.owner}</div>
                </div>
                <div style="overflow-x: auto;">
                    <table class="roster-table">
                        <thead>
                            <tr>
                                <th>Player</th>
                                <th>Team</th>
                                ${weekHeaders}
                                <th class="week-col season-col">Season</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${tableRows}
                        </tbody>
                    </table>
                </div>
                ${taxiHtml}
                ${picksHtml}
            `;
        }

        async function renderTeamHof() {
            if (!currentTeam || !data) return;
            
            const container = document.getElementById('team-hof-container');
            const teamInfo = data.standings?.find(t => t.abbrev === currentTeam);
            if (!teamInfo) {
                container.innerHTML = '<p class="no-banners">No team data available</p>';
                return;
            }
            
            // Show loading state
            container.innerHTML = '<p style="text-align: center; color: var(--text-muted);">Loading team history...</p>';
            
            // Owner name patterns for matching finishes (map team abbrev to possible owner name patterns)
            const ownerPatterns = {
                'GSA': ['Griffin', 'Griff'],
                'CGK': ['Kaminska', 'Connor Kaminska', 'Redacted Kaminska', 'CGK/SRY'],
                'CWR': ['Reardon', 'Connor Reardon', 'Censored Reardon', 'CWR/SLS'],
                'S/T': ['Spencer/Tim', 'Tim/Spencer', 'Spencer', 'Tim'],
                'SLS': ['Stephen', 'Schmidt', 'CWR/SLS'],
                'SRY': ['Spencer', 'CGK/SRY'],
                'AYP': ['Arnav'],
                'RPA': ['Ryan Ansel', 'Ryan A'],
                'RCP': ['Ryan P'],
                'WJK': ['Bill', 'Kusner'],
                'MPA': ['Miles'],
                'J/J': ['Joe/Joe', 'Joe Ward', 'Joe Kuhl'],
                'JRW': ['Joe Ward'],
                'JDK': ['Joe Kuhl'],
                'AST': ['Anagh']
            };
            
            const matchesTeam = (text, abbrev) => {
                const patterns = ownerPatterns[abbrev] || [];
                return patterns.some(p => text.toLowerCase().includes(p.toLowerCase()));
            };
            
            // Team Ring of Honor data (each * signifies a ring won with the franchise)
            const teamRingOfHonor = {
                'GSA': {
                    owners: [
                        { years: '2020 - Present', name: 'Griffin Ansel', rings: 3 }
                    ],
                    players: [
                        { position: 'RB', name: 'Dalvin Cook', team: 'MIN', rings: 2 },
                        { position: 'WR', name: 'Cooper Kupp', team: 'LAR', rings: 2 },
                        { position: 'RB', name: 'Nick Chubb', team: 'CLE', rings: 3 },
                        { position: 'WR', name: 'Tyreek Hill', team: 'MIA', rings: 3 },
                        { position: 'RB', name: 'Alvin Kamara', team: 'NO', rings: 3 }
                    ],
                    teamNames: [
                        { years: '2020', name: 'Beats by Joe and Tyreek', note: 'founding name' },
                        { years: '2020', name: 'The Mixon Administration' },
                        { years: '2021', name: 'Alvin, Dalvin, and the Chipmunks', rings: 1 },
                        { years: '2022', name: 'Mahomes\' Beermeister', rings: 1 },
                        { years: '2023', name: 'TuAnon' },
                        { years: '2024', name: 'All Roads Lead to Rome', rings: 1 }
                    ]
                },
                'CGK': {
                    owners: [
                        { years: '2020 - Present', name: 'Connor Kaminska', rings: 1 },
                        { years: '2021', name: 'Connor Kaminska & Spencer Yoder', rings: 0 }
                    ]
                },
                'CWR': {
                    owners: [
                        { years: '2020 - Present', name: 'Connor Reardon', rings: 1 },
                        { years: '2021', name: 'Connor Reardon & Stephen Schmidt', rings: 0 }
                    ]
                },
                'S/T': {
                    owners: [
                        { years: '2020 - Present', name: 'Spencer Yoder & Tim Grazier', rings: 1 }
                    ]
                },
                'SLS': {
                    owners: [
                        { years: '2020 - Present', name: 'Stephen Schmidt', rings: 0 }
                    ]
                },
                'AYP': {
                    owners: [
                        { years: '2020 - Present', name: 'Arnav Patel', rings: 0 }
                    ]
                },
                'RPA': {
                    owners: [
                        { years: '2020', name: 'Miles Agus', rings: 0 },
                        { years: '2021 - Present', name: 'Ryan Ansel', rings: 0 }
                    ]
                },
                'RCP': {
                    owners: [
                        { years: '2020 - Present', name: 'Ryan Przybocki', rings: 0 }
                    ]
                },
                'WJK': {
                    owners: [
                        { years: '2020 - Present', name: 'Bill Kuhl', rings: 0 }
                    ]
                },
                'MPA': {
                    owners: [
                        { years: '2020 - Present', name: 'Miles Agus', rings: 0 }
                    ]
                },
                'J/J': {
                    owners: [
                        { years: '2020 - 2022', name: 'Ryan Przybocki', rings: 0 },
                        { years: '2022 - 2023', name: 'Joe Kuhl', rings: 0 },
                        { years: '2024 - Present', name: 'Joe Kuhl & Joe Ward', rings: 0 }
                    ]
                },
                'AST': {
                    owners: [
                        { years: '2020 - 2024', name: 'Joe Ward', rings: 0 },
                        { years: '2024 - Present', name: 'Anagh Tiwary', rings: 0 }
                    ]
                }
            };
            
            // Load data from all available seasons
            const allSeasonData = [];
            const allTimePlayerGames = []; // For all-time top starter performances
            const highestScoringWeeks = []; // For highest team scores
            
            for (const season of availableSeasons) {
                try {
                    let seasonData;
                    if (season === currentSeason) {
                        seasonData = data;
                    } else {
                        const response = await fetch(`data_${season}.json?t=${Date.now()}`, { cache: 'no-store' });
                        if (response.ok) {
                            seasonData = await response.json();
                        } else {
                            continue;
                        }
                    }
                    
                    // Helper to check if an abbreviation matches this team (handles combined teams)
                    // CWR should also match CWR/SLS, CGK should match CGK/SRY
                    const matchesCurrentTeam = (abbrev) => {
                        if (abbrev === currentTeam) return true;
                        // Check if abbrev is a combined code that includes currentTeam
                        if (abbrev && abbrev.includes('/')) {
                            const parts = abbrev.split('/');
                            return parts.includes(currentTeam);
                        }
                        return false;
                    };
                    
                    // Check if this team exists in this season (including combined teams)
                    const teamExists = seasonData.standings?.some(t => matchesCurrentTeam(t.abbrev));
                    if (!teamExists) continue;
                    
                    const weeksWithScores = seasonData.weeks?.filter(w => w.has_scores) || [];
                    if (weeksWithScores.length === 0) continue;
                    
                    let highestScore = { score: 0, week: 0, opponent: '' };
                    let lowestScore = { score: Infinity, week: 0, opponent: '' };
                    let biggestWin = { margin: 0, week: 0, opponent: '', score: '' };
                    let biggestLoss = { margin: 0, week: 0, opponent: '', score: '' };
                    let totalPoints = 0;
                    let wins = 0, losses = 0, ties = 0;
                    let gamesPlayed = 0;
                    
                    weeksWithScores.forEach(week => {
                        for (const matchup of week.matchups) {
                            let teamData = null, opponentData = null;
                            
                            if (matchesCurrentTeam(matchup.team1.abbrev)) {
                                teamData = matchup.team1;
                                opponentData = matchup.team2;
                            } else if (matchesCurrentTeam(matchup.team2.abbrev)) {
                                teamData = matchup.team2;
                                opponentData = matchup.team1;
                            }
                            
                            if (!teamData) continue;
                            
                            const teamScore = teamData.total_score || 0;
                            const oppScore = opponentData.total_score || 0;
                            if (teamScore === 0 && oppScore === 0) continue;
                            
                            const margin = teamScore - oppScore;
                            totalPoints += teamScore;
                            gamesPlayed++;
                            
                            // Track for highest scoring weeks
                            highestScoringWeeks.push({
                                score: teamScore,
                                week: week.week,
                                season: season,
                                opponent: opponentData.abbrev,
                                result: teamScore > oppScore ? 'W' : (teamScore < oppScore ? 'L' : 'T')
                            });
                            
                            if (teamScore > oppScore) wins++;
                            else if (teamScore < oppScore) losses++;
                            else ties++;
                            
                            if (teamScore > highestScore.score) {
                                highestScore = { score: teamScore, week: week.week, opponent: opponentData.abbrev };
                            }
                            if (teamScore < lowestScore.score && teamScore > 0) {
                                lowestScore = { score: teamScore, week: week.week, opponent: opponentData.abbrev };
                            }
                            if (margin > biggestWin.margin) {
                                biggestWin = { margin, week: week.week, opponent: opponentData.abbrev, score: `${teamScore.toFixed(0)}-${oppScore.toFixed(0)}` };
                            }
                            if (margin < 0 && Math.abs(margin) > biggestLoss.margin) {
                                biggestLoss = { margin: Math.abs(margin), week: week.week, opponent: opponentData.abbrev, score: `${teamScore.toFixed(0)}-${oppScore.toFixed(0)}` };
                            }
                            
                            // Collect STARTER player performances only for all-time rankings
                            if (teamData.roster) {
                                teamData.roster.forEach(player => {
                                    if (player.score && player.score > 0 && player.starter) {
                                        allTimePlayerGames.push({
                                            name: player.name,
                                            position: player.position,
                                            nfl_team: player.nfl_team,
                                            score: player.score,
                                            week: week.week,
                                            season: season
                                        });
                                    }
                                });
                            }
                        }
                    });
                    
                    // Find season finish - check playoffs, toilet bowl, and standings position
                    const seasonFinishes = []; // Can have multiple badges (e.g., "10th" + "Toilet Bowl")
                    const finishes = data.hall_of_fame?.finishes_by_year || [];
                    const yearFinish = finishes.find(y => y.year === String(season) || y.year.includes(String(season)));
                    
                    if (yearFinish && yearFinish.results) {
                        // Check playoff positions
                        if (yearFinish.results[0] && matchesTeam(yearFinish.results[0], currentTeam)) {
                            seasonFinishes.push({ type: 'champion', label: 'Champion' });
                        } else if (yearFinish.results[1] && matchesTeam(yearFinish.results[1], currentTeam)) {
                            seasonFinishes.push({ type: 'playoff', label: '2nd Place' });
                        } else if (yearFinish.results[2] && matchesTeam(yearFinish.results[2], currentTeam)) {
                            seasonFinishes.push({ type: 'playoff', label: '3rd Place' });
                        }
                        
                        // Check toilet bowl/jambo
                        yearFinish.results.forEach(r => {
                            if (r.includes('Toilet Bowl') && matchesTeam(r, currentTeam)) {
                                seasonFinishes.push({ type: 'toilet-bowl', label: 'Toilet Bowl' });
                            } else if (r.includes('Jambo') && matchesTeam(r, currentTeam)) {
                                seasonFinishes.push({ type: 'jambo', label: 'Jamboree' });
                            }
                        });
                    }
                    
                    // Get standings position for this season (use matchesCurrentTeam for combined teams)
                    const teamStanding = seasonData.standings?.find(t => matchesCurrentTeam(t.abbrev));
                    if (teamStanding) {
                        const rank = teamStanding.rank || seasonData.standings.indexOf(teamStanding) + 1;
                        // Only show position badge if not already showing a playoff finish
                        if (!seasonFinishes.some(f => f.type === 'champion' || f.type === 'playoff')) {
                            // 4th-10th places get a position badge
                            if (rank >= 4 && rank <= 10) {
                                const suffix = rank === 4 ? 'th' : rank === 5 ? 'th' : rank === 6 ? 'th' : 
                                              rank === 7 ? 'th' : rank === 8 ? 'th' : rank === 9 ? 'th' : 'th';
                                seasonFinishes.unshift({ type: 'position', label: `${rank}${suffix} Place` });
                            }
                        }
                    }
                    
                    if (gamesPlayed > 0) {
                        allSeasonData.push({
                            season,
                            wins, losses, ties,
                            totalPoints,
                            gamesPlayed,
                            ppg: totalPoints / gamesPlayed,
                            highestScore,
                            lowestScore: lowestScore.score === Infinity ? null : lowestScore,
                            biggestWin: biggestWin.margin > 0 ? biggestWin : null,
                            biggestLoss: biggestLoss.margin > 0 ? biggestLoss : null,
                            seasonFinishes
                        });
                    }
                } catch (e) {
                    console.log(`Could not load season ${season}:`, e);
                }
            }
            
            // Sort seasons (most recent first)
            allSeasonData.sort((a, b) => b.season - a.season);
            
            // Calculate all-time franchise stats
            const allTimeTotalPoints = allSeasonData.reduce((sum, s) => sum + s.totalPoints, 0);
            const allTimeGamesPlayed = allSeasonData.reduce((sum, s) => sum + s.gamesPlayed, 0);
            const allTimeWins = allSeasonData.reduce((sum, s) => sum + s.wins, 0);
            const allTimeLosses = allSeasonData.reduce((sum, s) => sum + s.losses, 0);
            const allTimeTies = allSeasonData.reduce((sum, s) => sum + s.ties, 0);
            
            // Find largest margin of victory across all seasons
            let allTimeBiggestWin = { margin: 0, week: 0, season: 0, opponent: '', score: '' };
            allSeasonData.forEach(s => {
                if (s.biggestWin && s.biggestWin.margin > allTimeBiggestWin.margin) {
                    allTimeBiggestWin = { ...s.biggestWin, season: s.season };
                }
            });
            
            // Normalize player names to combine variants (e.g., "Patrick Mahomes" and "Patrick Mahomes II")
            const normalizePlayerName = (name) => {
                if (!name) return name;
                // Remove common suffixes
                let normalized = name
                    .replace(/\s+(II|III|IV|V|Jr\.?|Sr\.?)$/i, '')
                    .trim();
                return normalized;
            };
            
            // Aggregate total starter points per player across all seasons
            const playerTotalPoints = {};
            allTimePlayerGames.forEach(game => {
                const normalizedName = normalizePlayerName(game.name);
                const key = `${normalizedName}|${game.position}`;
                if (!playerTotalPoints[key]) {
                    playerTotalPoints[key] = {
                        name: game.name, // Keep original name for display (most recent)
                        position: game.position,
                        nfl_team: game.nfl_team,
                        totalPoints: 0,
                        gamesStarted: 0
                    };
                }
                playerTotalPoints[key].totalPoints += game.score;
                playerTotalPoints[key].gamesStarted += 1;
                // Keep the most recent name and NFL team
                playerTotalPoints[key].name = game.name;
                playerTotalPoints[key].nfl_team = game.nfl_team;
            });
            
            // Get top 10 players by total starter points
            const topPlayersByTotalPoints = Object.values(playerTotalPoints)
                .sort((a, b) => b.totalPoints - a.totalPoints)
                .slice(0, 10);
            
            // Get top 10 all-time STARTER performances
            const topAllTimeGames = allTimePlayerGames
                .sort((a, b) => b.score - a.score)
                .slice(0, 10);
            
            // Get top 10 all-time STARTER performances (Non-QB)
            const topAllTimeGamesNonQB = allTimePlayerGames
                .filter(p => p.position !== 'QB')
                .sort((a, b) => b.score - a.score)
                .slice(0, 10);
            
            // Get top 10 highest scoring weeks
            const topScoringWeeks = highestScoringWeeks
                .sort((a, b) => b.score - a.score)
                .slice(0, 10);
            
            // Find team banners (championship wins) - match by owner name patterns
            const teamBanners = [];
            const finishes = data.hall_of_fame?.finishes_by_year || [];
            finishes.forEach(year => {
                if (year.year.includes('MVP') || year.year === 'TBD') return;
                // First result is the champion
                if (year.results && year.results[0] && matchesTeam(year.results[0], currentTeam)) {
                    const yearNum = year.year.replace(/\D/g, '');
                    const bannerFile = data.banners?.find(b => b.includes(yearNum));
                    if (bannerFile) {
                        teamBanners.push({ year: year.year, file: bannerFile });
                    }
                }
            });
            
            // Check rivalry records for this team's head-to-head (including combined teams)
            // Need to combine records where currentTeam appears as CWR and CWR/SLS, etc.
            // Also combine opponents that are combined teams (e.g., CGK and CGK/SRY should be same opponent)
            const allRivalries = data.hall_of_fame?.rivalry_records?.records || [];
            
            // Helper to check if a rivalry team matches currentTeam (handles combined teams)
            const matchesRivalryTeam = (abbrev) => {
                if (abbrev === currentTeam) return true;
                if (abbrev && abbrev.includes('/')) {
                    return abbrev.split('/').includes(currentTeam);
                }
                return false;
            };
            
            // Known combined teams and their primary owners
            const combinedTeamPrimary = {
                'CWR/SLS': 'CWR',
                'CGK/SRY': 'CGK',
                'S/T': 'S/T',  // S/T is its own primary
                'J/J': 'J/J'   // J/J is its own primary
            };
            
            // Normalize opponent to primary team code
            const normalizeOpponent = (abbrev) => {
                // If it's a known combined team, return the primary
                if (combinedTeamPrimary[abbrev]) {
                    return combinedTeamPrimary[abbrev];
                }
                // If it contains a slash but isn't in our map, use first part as primary
                if (abbrev && abbrev.includes('/')) {
                    return abbrev.split('/')[0];
                }
                return abbrev;
            };
            
            // Aggregate records by normalized opponent
            const rivalryMap = {};
            
            allRivalries.forEach(r => {
                let opponent = null;
                let wins = 0, losses = 0, ties = 0;
                
                if (matchesRivalryTeam(r.team1)) {
                    opponent = r.team2;
                    wins = r.team1_wins;
                    losses = r.team2_wins;
                    ties = r.ties || 0;
                } else if (matchesRivalryTeam(r.team2)) {
                    opponent = r.team1;
                    wins = r.team2_wins;
                    losses = r.team1_wins;
                    ties = r.ties || 0;
                }
                
                if (opponent) {
                    // Skip if opponent is also a form of the current team (self-matchup from combined team)
                    if (matchesRivalryTeam(opponent)) return;
                    
                    // Normalize opponent to combine CGK and CGK/SRY, etc.
                    const opponentKey = normalizeOpponent(opponent);
                    
                    if (!rivalryMap[opponentKey]) {
                        rivalryMap[opponentKey] = { opponent: opponentKey, wins: 0, losses: 0, ties: 0 };
                    }
                    rivalryMap[opponentKey].wins += wins;
                    rivalryMap[opponentKey].losses += losses;
                    rivalryMap[opponentKey].ties += ties;
                }
            });
            
            const rivalryRecords = Object.values(rivalryMap);
            
            // Build HTML
            let html = `<h2 style="text-align: center; margin-bottom: 1.5rem;">${teamInfo.name} Hall of Fame</h2>`;
            
            // Championship Banners
            html += `
                <div class="team-hof-section">
                    <div class="team-hof-section-title">Championship Banners</div>
                    ${teamBanners.length > 0 ? `
                        <div class="team-banners-grid">
                            ${teamBanners.map(b => `
                                <div class="team-banner-item">
                                    <img src="images/banners/${b.file}" alt="${b.year} Championship">
                                    <div style="text-align: center; margin-top: 0.5rem; color: var(--text-secondary);">${b.year}</div>
                                </div>
                            `).join('')}
                        </div>
                    ` : `<p class="no-banners">No championships yet...</p>`}
                </div>
            `;
            
            // Team Ring of Honor (if data exists for this team)
            const ringOfHonor = teamRingOfHonor[currentTeam];
            if (ringOfHonor) {
                // Helper to render rings as asterisks
                const renderRings = (count) => '*'.repeat(count || 0);
                
                html += `
                    <div class="team-hof-section ring-of-honor">
                        <div class="team-hof-section-title">Team Ring of Honor</div>
                        <p style="color: var(--text-muted); font-size: 0.85rem; margin-bottom: 1rem; font-style: italic;">
                            Each * signifies a ring won with the franchise
                        </p>
                        
                        ${ringOfHonor.owners && ringOfHonor.owners.length > 0 ? `
                            <div class="ring-of-honor-category">
                                <div class="ring-of-honor-category-title">Team Owners</div>
                                ${ringOfHonor.owners.map(o => `
                                    <div class="ring-of-honor-entry">
                                        <span class="ring-years">${o.years}:</span>
                                        <span class="ring-name">${o.name}</span>
                                        <span class="ring-stars">${renderRings(o.rings)}</span>
                                    </div>
                                `).join('')}
                            </div>
                        ` : ''}
                        
                        ${ringOfHonor.players && ringOfHonor.players.length > 0 ? `
                            <div class="ring-of-honor-category">
                                <div class="ring-of-honor-category-title">Players</div>
                                ${ringOfHonor.players.map(p => `
                                    <div class="ring-of-honor-entry">
                                        <span class="ring-name">${p.position} ${p.name} (${p.team})</span>
                                        <span class="ring-stars">${renderRings(p.rings)}</span>
                                    </div>
                                `).join('')}
                            </div>
                        ` : ''}
                        
                        ${ringOfHonor.teamNames && ringOfHonor.teamNames.length > 0 ? `
                            <div class="ring-of-honor-category">
                                <div class="ring-of-honor-category-title">Team Names</div>
                                ${ringOfHonor.teamNames.map(t => `
                                    <div class="ring-of-honor-entry">
                                        <span class="ring-years">${t.years}</span>
                                        <span class="ring-name">- ${t.name}${t.note ? ` (${t.note})` : ''}</span>
                                        <span class="ring-stars">${renderRings(t.rings)}</span>
                                    </div>
                                `).join('')}
                            </div>
                        ` : ''}
                    </div>
                `;
            }
            
            // All-Time Franchise Records
            if (allSeasonData.length > 0) {
                html += `
                    <div class="team-hof-section">
                        <div class="team-hof-section-title">All-Time Franchise Records</div>
                        <div class="team-hof-record">
                            <span class="team-hof-record-label">All-Time Record</span>
                            <span class="team-hof-record-value">${allTimeWins}-${allTimeLosses}${allTimeTies > 0 ? `-${allTimeTies}` : ''}</span>
                        </div>
                        <div class="team-hof-record">
                            <span class="team-hof-record-label">Total Points Scored</span>
                            <span class="team-hof-record-value">${allTimeTotalPoints.toFixed(0)} pts (${allTimeGamesPlayed} games)</span>
                        </div>
                        <div class="team-hof-record">
                            <span class="team-hof-record-label">Points Per Game (All-Time)</span>
                            <span class="team-hof-record-value">${(allTimeTotalPoints / allTimeGamesPlayed).toFixed(1)} PPG</span>
                        </div>
                        ${allTimeBiggestWin.margin > 0 ? `
                            <div class="team-hof-record">
                                <span class="team-hof-record-label">Largest Margin of Victory</span>
                                <span class="team-hof-record-value">+${allTimeBiggestWin.margin.toFixed(0)} pts (${allTimeBiggestWin.season} Week ${allTimeBiggestWin.week} vs ${allTimeBiggestWin.opponent}, ${allTimeBiggestWin.score})</span>
                            </div>
                        ` : ''}
                    </div>
                `;
            }
            
            // Top Players by Total Starter Points (All-Time)
            if (topPlayersByTotalPoints.length > 0) {
                html += `
                    <div class="team-hof-section">
                        <div class="team-hof-section-title">Most Total Points as Starter (All-Time)</div>
                        ${topPlayersByTotalPoints.map((p, i) => `
                            <div class="team-hof-record">
                                <span class="team-hof-record-label">${i + 1}. ${p.position} ${p.name} (${p.nfl_team || 'N/A'})</span>
                                <span class="team-hof-record-value">${p.totalPoints.toFixed(0)} pts (${p.gamesStarted} starts)</span>
                            </div>
                        `).join('')}
                    </div>
                `;
            }
            
            // Finishes by Year header and season-by-season records
            if (allSeasonData.length > 0) {
                html += `<h3 style="text-align: center; margin: 2rem 0 1rem; color: var(--text-primary);">Finishes by Year</h3>`;
                
                allSeasonData.forEach(s => {
                    const finishBadges = s.seasonFinishes?.map(f => {
                        let badgeClass = 'playoff-finish-badge';
                        if (f.type === 'champion') badgeClass += ' champion';
                        else if (f.type === 'toilet-bowl') badgeClass += ' toilet-bowl';
                        else if (f.type === 'jambo') badgeClass += ' jambo';
                        return `<span class="${badgeClass}">${f.label}</span>`;
                    }).join(' ') || '';
                    
                    html += `
                        <div class="team-hof-section">
                            <div class="team-hof-section-title">${s.season} Season ${finishBadges}</div>
                            <div class="team-hof-record">
                                <span class="team-hof-record-label">Record</span>
                                <span class="team-hof-record-value">${s.wins}-${s.losses}${s.ties > 0 ? `-${s.ties}` : ''}</span>
                            </div>
                            <div class="team-hof-record">
                                <span class="team-hof-record-label">Total Points</span>
                                <span class="team-hof-record-value">${s.totalPoints.toFixed(1)}</span>
                            </div>
                            <div class="team-hof-record">
                                <span class="team-hof-record-label">Points Per Game</span>
                                <span class="team-hof-record-value">${s.ppg.toFixed(1)}</span>
                            </div>
                            <div class="team-hof-record">
                                <span class="team-hof-record-label">Highest Score</span>
                                <span class="team-hof-record-value">${s.highestScore.score.toFixed(1)} (Week ${s.highestScore.week} vs ${s.highestScore.opponent})</span>
                            </div>
                            ${s.lowestScore ? `
                                <div class="team-hof-record">
                                    <span class="team-hof-record-label">Lowest Score</span>
                                    <span class="team-hof-record-value">${s.lowestScore.score.toFixed(1)} (Week ${s.lowestScore.week} vs ${s.lowestScore.opponent})</span>
                                </div>
                            ` : ''}
                            ${s.biggestWin ? `
                                <div class="team-hof-record">
                                    <span class="team-hof-record-label">Biggest Win</span>
                                    <span class="team-hof-record-value">+${s.biggestWin.margin.toFixed(1)} (Week ${s.biggestWin.week} vs ${s.biggestWin.opponent}, ${s.biggestWin.score})</span>
                                </div>
                            ` : ''}
                            ${s.biggestLoss ? `
                                <div class="team-hof-record">
                                    <span class="team-hof-record-label">Biggest Loss</span>
                                    <span class="team-hof-record-value">-${s.biggestLoss.margin.toFixed(1)} (Week ${s.biggestLoss.week} vs ${s.biggestLoss.opponent}, ${s.biggestLoss.score})</span>
                                </div>
                            ` : ''}
                        </div>
                    `;
                });
            }
            
            // Highest Scoring Weeks
            if (topScoringWeeks.length > 0) {
                html += `
                    <div class="team-hof-section">
                        <div class="team-hof-section-title">Highest Scoring Weeks (All-Time)</div>
                        ${topScoringWeeks.map((w, i) => `
                            <div class="team-hof-record">
                                <span class="team-hof-record-label">${i + 1}. ${w.season} Week ${w.week} vs ${w.opponent}</span>
                                <span class="team-hof-record-value">${w.score.toFixed(0)} pts (${w.result})</span>
                            </div>
                        `).join('')}
                    </div>
                `;
            }
            
            // All-Time Top STARTER Performances
            if (topAllTimeGames.length > 0) {
                html += `
                    <div class="team-hof-section">
                        <div class="team-hof-section-title">Top Starter Performances (All-Time)</div>
                        ${topAllTimeGames.map((p, i) => `
                            <div class="team-hof-record">
                                <span class="team-hof-record-label">${i + 1}. ${p.position} ${p.name} (${p.nfl_team || 'N/A'})</span>
                                <span class="team-hof-record-value">${p.score.toFixed(0)} pts (${p.season} Week ${p.week})</span>
                            </div>
                        `).join('')}
                    </div>
                `;
            }
            
            // All-Time Top STARTER Performances (Non-QB)
            if (topAllTimeGamesNonQB.length > 0) {
                html += `
                    <div class="team-hof-section">
                        <div class="team-hof-section-title">Top Starter Performances - Non-QB (All-Time)</div>
                        ${topAllTimeGamesNonQB.map((p, i) => `
                            <div class="team-hof-record">
                                <span class="team-hof-record-label">${i + 1}. ${p.position} ${p.name} (${p.nfl_team || 'N/A'})</span>
                                <span class="team-hof-record-value">${p.score.toFixed(0)} pts (${p.season} Week ${p.week})</span>
                            </div>
                        `).join('')}
                    </div>
                `;
            }
            
            // Head-to-Head Records
            if (rivalryRecords.length > 0) {
                html += `
                    <div class="team-hof-section">
                        <div class="team-hof-section-title">All-Time Head-to-Head</div>
                        ${rivalryRecords.sort((a, b) => (b.wins + b.losses + b.ties) - (a.wins + a.losses + a.ties)).map(r => {
                            const total = r.wins + r.losses + r.ties;
                            const recordClass = r.wins > r.losses ? 'color: var(--accent);' : (r.losses > r.wins ? 'color: #e74c3c;' : '');
                            return `
                                <div class="team-hof-record">
                                    <span class="team-hof-record-label">vs ${r.opponent}</span>
                                    <span class="team-hof-record-value" style="${recordClass}">${r.wins}-${r.losses}${r.ties > 0 ? `-${r.ties}` : ''} (${total} games)</span>
                                </div>
                            `;
                        }).join('')}
                    </div>
                `;
            }
            
            container.innerHTML = html;
        }

        function renderTeamTradeBlock() {
            if (!currentTeam || !data) return;
            
            const container = document.getElementById('team-tradeblock-container');
            const tradeBlocks = data.trade_blocks || {};
            const teamBlock = tradeBlocks[currentTeam] || {};
            
            const seeking = teamBlock.seeking || [];
            const tradingAway = teamBlock.trading_away || [];
            const playersAvailable = teamBlock.players_available || [];
            const notes = teamBlock.notes || '';
            
            // Check if trade block is empty
            if (!seeking.length && !tradingAway.length && !playersAvailable.length && !notes) {
                container.innerHTML = `
                    <div class="trade-block-empty">
                        <div class="trade-block-empty-icon"></div>
                        <p>This team hasn't set up their trade block yet.</p>
                    </div>
                `;
                return;
            }
            
            let html = '';
            
            // Seeking positions
            if (seeking.length) {
                html += `
                    <div class="trade-block-section">
                        <h3 class="trade-block-section-title seeking">Looking For</h3>
                        <div class="trade-block-positions">
                            ${seeking.map(pos => `<span class="trade-block-position seeking">${pos}</span>`).join('')}
                        </div>
                    </div>
                `;
            }
            
            // Trading away positions
            if (tradingAway.length) {
                html += `
                    <div class="trade-block-section">
                        <h3 class="trade-block-section-title trading">Willing to Trade</h3>
                        <div class="trade-block-positions">
                            ${tradingAway.map(pos => `<span class="trade-block-position trading">${pos}</span>`).join('')}
                        </div>
                    </div>
                `;
            }
            
            // Players available
            if (playersAvailable.length) {
                // Get player details from roster
                const roster = data.rosters?.[currentTeam] || [];
                const allPlayers = Array.isArray(roster) ? roster : [...(roster.roster || []), ...(roster.taxi_squad || [])];
                
                html += `
                    <div class="trade-block-section">
                        <h3 class="trade-block-section-title trading">Players Available</h3>
                        <div class="trade-block-players">
                            ${playersAvailable.map(playerName => {
                                const player = allPlayers.find(p => p.name === playerName);
                                const pos = player?.position || '';
                                return `
                                    <div class="trade-block-player">
                                        <span class="trade-block-player-pos">${pos}</span>
                                        <span class="trade-block-player-name">${playerName}</span>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                `;
            }
            
            // Notes
            if (notes) {
                html += `
                    <div class="trade-block-section">
                        <h3 class="trade-block-section-title">Notes</h3>
                        <div class="trade-block-notes">${notes}</div>
                    </div>
                `;
            }
            
            container.innerHTML = html;
        }

        function renderBanners() {
            if (!data.banners) return;
            
            const container = document.getElementById('banners-container');
            // Reverse to show most recent banner first
            const sortedBanners = [...data.banners].reverse();
            container.innerHTML = sortedBanners.map(img => `
                <div class="banner-item">
                    <img src="images/banners/${img}" alt="Championship Banner" loading="lazy">
                </div>
            `).join('');
        }

        function renderHallOfFame() {
            if (!data.hall_of_fame) return;
            
            const hof = data.hall_of_fame;
            const container = document.getElementById('hof-container');
            
            let html = '';
            
            // Owner Stats Table
            if (hof.owner_stats && hof.owner_stats.length > 0) {
                // Calculate leaders for each category (for underlining)
                const parseWins = (record) => parseInt(record?.split('-')[0]) || 0;
                const parsePct = (pct) => parseFloat(pct?.replace('%', '')) || 0;
                const parseNum = (n) => parseInt(n) || 0;
                
                const maxSeasons = Math.max(...hof.owner_stats.map(o => parseNum(o.Seasons)));
                const maxWins = Math.max(...hof.owner_stats.map(o => parseWins(o.Record)));
                const maxWinPct = Math.max(...hof.owner_stats.map(o => parsePct(o['Win%'])));
                const maxPlayoffs = Math.max(...hof.owner_stats.map(o => parseNum(o['Playoff Berths'])));
                const maxPOWinPct = Math.max(...hof.owner_stats.filter(o => parseNum(o['Playoff Berths']) > 0).map(o => parsePct(o['Playoff Win%'])));
                const max3rd = Math.max(...hof.owner_stats.map(o => parseNum(o['3rd Place'])));
                const max2nd = Math.max(...hof.owner_stats.map(o => parseNum(o['2nd Place'])));
                const maxRings = Math.max(...hof.owner_stats.map(o => parseNum(o.Rings)));
                const maxPrestige = Math.max(...hof.owner_stats.map(o => parseFloat(o.Prestige) || 0));
                
                const underlineIf = (val, max, display) => val === max && max > 0 ? `<u>${display}</u>` : display;
                
                html += `
                    <div class="hof-section">
                        <div class="hof-section-title">Owner Statistics</div>
                        <div class="table-scroll-wrapper">
                        <table class="owner-stats-table">
                            <thead>
                                <tr>
                                    <th>Owner</th>
                                    <th>Seasons</th>
                                    <th>Record</th>
                                    <th>Win%</th>
                                    <th>Playoffs</th>
                                    <th>PO Record</th>
                                    <th>PO Win%</th>
                                    <th>3rd</th>
                                    <th>2nd</th>
                                    <th>Rings</th>
                                    <th>Prestige</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${hof.owner_stats.map(owner => {
                                    const seasons = parseNum(owner.Seasons);
                                    const wins = parseWins(owner.Record);
                                    const winPct = parsePct(owner['Win%']);
                                    const playoffs = parseNum(owner['Playoff Berths']);
                                    const poWinPct = parsePct(owner['Playoff Win%']);
                                    const third = parseNum(owner['3rd Place']);
                                    const second = parseNum(owner['2nd Place']);
                                    const rings = parseNum(owner.Rings);
                                    const prestige = parseFloat(owner.Prestige) || 0;
                                    
                                    return `
                                    <tr>
                                        <td>${owner.Owner || ''}</td>
                                        <td>${underlineIf(seasons, maxSeasons, owner.Seasons || '')}</td>
                                        <td>${underlineIf(wins, maxWins, owner.Record || '')}</td>
                                        <td>${underlineIf(winPct, maxWinPct, owner['Win%'] || '')}</td>
                                        <td>${underlineIf(playoffs, maxPlayoffs, owner['Playoff Berths'] || '')}</td>
                                        <td>${owner['Playoff Record'] || '0-0'}</td>
                                        <td>${playoffs > 0 ? underlineIf(poWinPct, maxPOWinPct, owner['Playoff Win%'] || '0%') : (owner['Playoff Win%'] || '0%')}</td>
                                        <td>${underlineIf(third, max3rd, owner['3rd Place'] || '0')}</td>
                                        <td>${underlineIf(second, max2nd, owner['2nd Place'] || '0')}</td>
                                        <td class="rings">${underlineIf(rings, maxRings, 'ðŸ†'.repeat(rings))}</td>
                                        <td class="prestige">${underlineIf(prestige, maxPrestige, owner.Prestige || '0.00')}</td>
                                    </tr>
                                `;}).join('')}
                            </tbody>
                        </table>
                        </div>
                        <div class="formula-note">
                            <strong>Prestige Formula:</strong> (1 + Championships Ã— 0.2) Ã— { (Reg Season Games Ã— Reg Season Win% / League Avg Reg Win% Ã— 0.1) + (Playoff Games Ã— Playoff Win% / League Avg Playoff Win% Ã— 0.2) } / Seasons
                        </div>
                    </div>
                `;
            }
            
            // Finishes by Year (filter out MVPs section and empty entries)
            let yearResults = hof.finishes_by_year?.filter(y => 
                !y.year.includes('MVP') && 
                y.results && 
                y.results.length > 0
            ) || [];
            
            // Sort by year descending (most recent first)
            yearResults = yearResults.sort((a, b) => parseInt(b.year) - parseInt(a.year));
            const mvpSection = hof.finishes_by_year?.find(y => y.year.includes('MVP'));
            
            if (yearResults.length > 0) {
                html += `
                    <div class="hof-section">
                        <div class="hof-section-title">Season Finishes</div>
                        <div class="hof-seasons-list">
                        ${yearResults.map(year => {
                            const stats = year.league_stats || {};
                            const champion = year.results?.[0] || 'Unknown';
                            const runnerUp = year.results?.[1] || '';
                            const thirdPlace = year.results?.[2] || '';
                            const toiletBowl = year.results?.find(r => r.includes('Toilet Bowl'));
                            
                            return `
                            <div class="hof-season-card">
                                <div class="hof-season-header">
                                    <div class="hof-season-year">${year.year}</div>
                                    <div class="hof-season-champion">
                                        <span class="champion-crown">ðŸ‘‘</span> ${champion}
                                    </div>
                                </div>
                                <div class="hof-season-body">
                                    <div class="hof-season-podium">
                                        ${runnerUp ? `<div class="podium-item"><span class="podium-badge silver">2nd</span> ${runnerUp}</div>` : ''}
                                        ${thirdPlace ? `<div class="podium-item"><span class="podium-badge bronze">3rd</span> ${thirdPlace}</div>` : ''}
                                    </div>
                                    ${stats.avg_ppg ? `
                                    <div class="hof-season-stats-detailed">
                                        <div class="stat-row">
                                            <span class="stat-label">League Average PPG</span>
                                            <span class="stat-value">${stats.avg_ppg?.toFixed(1) || 'N/A'}</span>
                                        </div>
                                        <div class="stat-row">
                                            <span class="stat-label">High Score</span>
                                            <span class="stat-value">${stats.highest_score?.toFixed(0)} <span class="stat-context">by ${stats.highest_score_team} (Week ${stats.highest_score_week})</span></span>
                                        </div>
                                        <div class="stat-row">
                                            <span class="stat-label">Low Score</span>
                                            <span class="stat-value">${stats.lowest_score?.toFixed(0)} <span class="stat-context">by ${stats.lowest_score_team} (Week ${stats.lowest_score_week})</span></span>
                                        </div>
                                        <div class="stat-row">
                                            <span class="stat-label">Biggest Win</span>
                                            <span class="stat-value">+${stats.biggest_win?.toFixed(0)} <span class="stat-context">${stats.biggest_win_winner} over ${stats.biggest_win_loser} (Week ${stats.biggest_win_week})</span></span>
                                        </div>
                                        ${stats.rivalry_winner ? `
                                        <div class="stat-row rivalry-row">
                                            <span class="stat-label">ðŸ† Rivalry Week</span>
                                            <span class="stat-value">+${stats.rivalry_margin?.toFixed(0)} <span class="stat-context">${stats.rivalry_winner} over ${stats.rivalry_loser}</span></span>
                                        </div>
                                        ` : ''}
                                    </div>
                                    ` : ''}
                                    ${toiletBowl ? `<div class="hof-toilet-bowl">${toiletBowl}</div>` : ''}
                                </div>
                            </div>
                            `;
                        }).join('')}
                        </div>
                    </div>
                `;
            }
            
            // MVPs (from mvps array or finishes_by_year)
            const mvps = hof.mvps?.length > 0 ? hof.mvps : (mvpSection?.results || []);
            if (mvps.length > 0) {
                html += `
                    <div class="hof-section">
                        <div class="hof-section-title">League MVPs</div>
                        ${mvps.map(mvp => `<div class="record-item">${mvp}</div>`).join('')}
                    </div>
                `;
            }
            
            // Team Records
            if (hof.team_records && hof.team_records.length > 0) {
                html += `
                    <div class="hof-section">
                        <div class="hof-section-title">Team Records</div>
                        ${hof.team_records.map(section => `
                            <div class="record-subsection">
                                <div class="record-subsection-title">${section.title}</div>
                                ${section.records.map(r => `<div class="record-item">${r}</div>`).join('')}
                            </div>
                        `).join('')}
                    </div>
                `;
            }
            
            // Player Records
            if (hof.player_records && hof.player_records.length > 0) {
                html += `
                    <div class="hof-section">
                        <div class="hof-section-title">Player Records</div>
                        ${hof.player_records.map(section => `
                            <div class="record-subsection">
                                <div class="record-subsection-title">${section.title}</div>
                                ${section.records.map(r => `<div class="record-item">${r}</div>`).join('')}
                            </div>
                        `).join('')}
                    </div>
                `;
            }
            
            // Rivalry Records (Head-to-Head) - Only show official Rivalry Week matchups
            if (hof.rivalry_records && hof.rivalry_records.records && hof.rivalry_records.records.length > 0) {
                // Official "Rivalry Week" matchups only
                const rivalryWeekMatchups = [
                    ['GSA', 'RPA'],
                    ['AST', 'AYP'],
                    ['CGK', 'CWR'],
                    ['J/J', 'WJK'],
                    ['S/T', 'SLS']
                ];
                
                const isRivalryWeek = (t1, t2) => {
                    return rivalryWeekMatchups.some(([a, b]) => 
                        (t1 === a && t2 === b) || (t1 === b && t2 === a)
                    );
                };
                
                // Filter to only show official rivalry week matchups
                const rivalries = hof.rivalry_records.records.filter(r => isRivalryWeek(r.team1, r.team2));
                
                if (rivalries.length > 0) {
                    html += `
                        <div class="hof-section">
                            <div class="hof-section-title">Rivalry Week Records</div>
                            <div class="table-scroll-wrapper">
                            <table class="rivalry-table">
                                <thead>
                                    <tr>
                                        <th>Team 1</th>
                                        <th>Record</th>
                                        <th>Team 2</th>
                                        <th>Games</th>
                                        <th>Points</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${rivalries.map(r => {
                                        const t1Class = r.leader === r.team1 ? 'rivalry-leader' : '';
                                        const t2Class = r.leader === r.team2 ? 'rivalry-leader' : '';
                                        const recordStr = r.ties > 0 
                                            ? `${r.team1_wins}-${r.team2_wins}-${r.ties}`
                                            : `${r.team1_wins}-${r.team2_wins}`;
                                        return `
                                        <tr class="rivalry-week-row">
                                            <td class="${t1Class}"><span class="rivalry-week-indicator">â˜…</span> ${r.team1}</td>
                                            <td class="rivalry-record">${recordStr}</td>
                                            <td class="${t2Class}">${r.team2}</td>
                                            <td>${r.games}</td>
                                            <td class="rivalry-points">${r.team1_pf.toFixed(0)} - ${r.team2_pf.toFixed(0)}</td>
                                        </tr>
                                    `;}).join('')}
                                </tbody>
                            </table>
                            </div>
                        </div>
                    `;
                }
            }
            
            container.innerHTML = html;
        }

        let currentTransactionSeason = null;  // Will be set to current year on first render

        function renderTransactions() {
            if (!data.transactions || data.transactions.length === 0) {
                document.getElementById('transactions-container').innerHTML = '<p style="text-align:center; color: var(--text-secondary);">No transactions available</p>';
                return;
            }
            
            const selectorContainer = document.getElementById('transactions-season-selector');
            const container = document.getElementById('transactions-container');
            
            // Flat format: [{type, team, week, season, message, timestamp, ...}]
            // Group by season first
            const bySeason = {};
            data.transactions.forEach(tx => {
                const season = tx.season || data.season || 2025;
                if (!bySeason[season]) bySeason[season] = [];
                bySeason[season].push(tx);
            });
            
            // Get sorted seasons (descending)
            const seasons = Object.keys(bySeason).sort((a, b) => parseInt(b) - parseInt(a));
            
            // Default to current season
            if (currentTransactionSeason === null) {
                currentTransactionSeason = parseInt(seasons[0]) || data.season || 2025;
            }
            
            // Render season selector
            selectorContainer.innerHTML = seasons.map(season => `
                <button class="season-btn ${parseInt(season) === currentTransactionSeason ? 'active' : ''}" 
                        data-season="${season}">${season}</button>
            `).join('');
            
            selectorContainer.querySelectorAll('.season-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    currentTransactionSeason = parseInt(btn.dataset.season);
                    renderTransactions();
                });
            });
            
            // Get transactions for selected season
            const seasonTxns = bySeason[currentTransactionSeason] || [];
            
            // Group by week
            const byWeek = {};
            seasonTxns.forEach(tx => {
                const week = tx.week || 0;
                if (!byWeek[week]) byWeek[week] = [];
                byWeek[week].push(tx);
            });
            
            // Sort weeks descending
            const sortedWeeks = Object.keys(byWeek).sort((a, b) => parseInt(b) - parseInt(a));
            
            container.innerHTML = `
                <div class="transactions-season">
                    ${sortedWeeks.map(week => `
                        <div class="transactions-week">
                            <div class="transactions-week-header">${isNaN(parseInt(week)) ? week : `Week ${week}`}</div>
                            ${byWeek[week].map(tx => {
                                // For trades, check for new format (proposer/partner) or old format (team with "Trade")
                                const isNewTrade = tx.type === 'trade' && tx.proposer && tx.partner;
                                const isOldTrade = tx.team && tx.team.toLowerCase().includes('trade');
                                const isTrade = isNewTrade || isOldTrade;
                                
                                let teamName;
                                if (isNewTrade) {
                                    const proposerName = data.teams?.find(t => t.abbrev === tx.proposer)?.name || tx.proposer;
                                    const partnerName = data.teams?.find(t => t.abbrev === tx.partner)?.name || tx.partner;
                                    teamName = `Trade: ${proposerName} â†” ${partnerName}`;
                                } else if (isOldTrade) {
                                    teamName = tx.team;
                                } else {
                                    teamName = data.teams?.find(t => t.abbrev === tx.team)?.name || tx.team;
                                }
                                
                                return `
                                    <div class="transaction-item">
                                        <div class="transaction-title">${teamName}</div>
                                        <div class="transaction-details">
                                            <div class="transaction-subheader">${tx.message || formatTransactionMessage(tx)}</div>
                                        </div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    `).join('')}
                </div>
            `;
        }

        // Drafts
        let currentDraft = 0;

        function renderDrafts() {
            if (!data.drafts || data.drafts.length === 0) {
                document.getElementById('drafts-container').innerHTML = '<p style="text-align:center; color: var(--text-secondary);">No drafts available</p>';
                return;
            }
            
            // Render draft tabs
            const tabsContainer = document.getElementById('drafts-tabs');
            tabsContainer.innerHTML = data.drafts.map((draft, idx) => `
                <button class="season-btn ${idx === currentDraft ? 'active' : ''}" 
                        data-draft="${idx}">${draft.name}</button>
            `).join('');
            
            // Add click handlers
            tabsContainer.querySelectorAll('.season-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    currentDraft = parseInt(btn.dataset.draft);
                    renderDrafts();
                });
            });
            
            // Render selected draft
            const draft = data.drafts[currentDraft];
            const container = document.getElementById('drafts-container');
            
            if (!draft.rounds || draft.rounds.length === 0) {
                container.innerHTML = '<p style="text-align:center; color: var(--text-secondary);">No picks recorded for this draft</p>';
                return;
            }
            
            container.innerHTML = `
                <div class="drafts-season">
                    ${draft.rounds.map(round => `
                        <div class="draft-round">
                            <div class="draft-round-header">Round ${String(round.round).includes('Taxi') ? round.round : (Number.isInteger(parseFloat(round.round)) ? parseInt(round.round) : round.round)}</div>
                            <div class="draft-picks-grid">
                                ${round.picks.map(pick => {
                                    const isPass = pick.player === 'PASS' || !pick.player;
                                    return `
                                        <div class="draft-pick">
                                            <div class="pick-number">${pick.pick}</div>
                                            <div class="pick-details">
                                                <div class="pick-team">${pick.team}</div>
                                                ${isPass 
                                                    ? '<div class="pick-player pick-pass">PASS</div>'
                                                    : `<div class="pick-player">${pick.player}</div>`
                                                }
                                                ${pick.dropped && pick.dropped !== '-' 
                                                    ? `<div class="pick-dropped">Dropped: <span>${pick.dropped}</span></div>` 
                                                    : ''
                                                }
                                            </div>
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        // Stats Leaders
        let currentStatsPosition = 'ALL';

        function getStatsLeaders() {
            // Aggregate player stats across all weeks
            const playerStats = {};  // key: "playerName|nflTeam" -> {name, nfl_team, position, fantasy_team, total_points}
            
            if (!data) return {};
            
            // First, add all players from current rosters (so everyone rostered is included)
            if (data.rosters) {
                for (const [teamAbbrev, roster] of Object.entries(data.rosters)) {
                    for (const player of roster) {
                        if (!player.name || !player.position) continue;
                        
                        // Include position in key to differentiate OL vs D/ST for same NFL team
                        const key = `${player.name}|${player.nfl_team || ''}|${player.position}`;
                        
                        if (!playerStats[key]) {
                            playerStats[key] = {
                                name: player.name,
                                nfl_team: player.nfl_team || '',
                                position: player.position,
                                fantasy_team: teamAbbrev,
                                total_points: 0,
                                weeks_played: 0
                            };
                        }
                    }
                }
            }
            
            // Then aggregate stats from matchups
            if (data.weeks) {
                for (const week of data.weeks) {
                    if (!week.matchups) continue;
                    
                    for (const matchup of week.matchups) {
                        for (const teamData of [matchup.team1, matchup.team2]) {
                            const fantasyTeam = teamData.abbrev;
                            const roster = teamData.roster || [];
                            
                            for (const player of roster) {
                                if (!player.name || !player.position) continue;
                                
                                // Include position in key to differentiate OL vs D/ST for same NFL team
                                const key = `${player.name}|${player.nfl_team || ''}|${player.position}`;
                                
                                if (!playerStats[key]) {
                                    playerStats[key] = {
                                        name: player.name,
                                        nfl_team: player.nfl_team || '',
                                        position: player.position,
                                        fantasy_team: fantasyTeam,
                                        total_points: 0,
                                        weeks_played: 0
                                    };
                                }
                                
                                // Always update fantasy team to track ownership
                                playerStats[key].fantasy_team = fantasyTeam;
                                
                                // Add points if player has a score (including negative)
                                if (player.score !== undefined && player.score !== null) {
                                    playerStats[key].total_points += player.score;
                                    if (player.score !== 0) {
                                        playerStats[key].weeks_played++;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            // Group by position
            const byPosition = {};
            for (const player of Object.values(playerStats)) {
                if (!byPosition[player.position]) {
                    byPosition[player.position] = [];
                }
                byPosition[player.position].push(player);
            }
            
            // Sort each position by total points descending
            for (const pos of Object.keys(byPosition)) {
                byPosition[pos].sort((a, b) => b.total_points - a.total_points);
            }
            
            return byPosition;
        }

        function renderStatsLeaders() {
            const leaders = getStatsLeaders();
            const positions = ['QB', 'RB', 'WR', 'TE', 'K', 'D/ST', 'HC', 'OL'];
            const positionNames = {
                'QB': 'Quarterbacks',
                'RB': 'Running Backs',
                'WR': 'Wide Receivers',
                'TE': 'Tight Ends',
                'K': 'Kickers',
                'D/ST': 'Defenses',
                'HC': 'Head Coaches',
                'OL': 'Offensive Lines'
            };
            
            // Render position selector
            const selector = document.getElementById('stats-position-selector');
            selector.innerHTML = `
                <button class="stats-pos-btn ${currentStatsPosition === 'ALL' ? 'active' : ''}" data-pos="ALL">All</button>
                ${positions.map(pos => `
                    <button class="stats-pos-btn ${currentStatsPosition === pos ? 'active' : ''}" data-pos="${pos}">${pos}</button>
                `).join('')}
            `;
            
            selector.querySelectorAll('.stats-pos-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    currentStatsPosition = btn.dataset.pos;
                    renderStatsLeaders();
                });
            });
            
            // Render leaders grid
            const container = document.getElementById('stats-leaders-container');
            const positionsToShow = currentStatsPosition === 'ALL' ? positions : [currentStatsPosition];
            
            container.innerHTML = positionsToShow.map(pos => {
                const posLeaders = currentStatsPosition === 'ALL' 
                    ? (leaders[pos] || []).slice(0, 5)
                    : (leaders[pos] || []);
                if (posLeaders.length === 0) return '';
                
                return `
                    <div class="stats-position-card">
                        <div class="stats-position-header">${positionNames[pos] || pos}</div>
                        ${posLeaders.map((player, idx) => {
                            const rank = idx + 1;
                            const rankClass = rank <= 3 ? `rank-${rank}` : '';
                            return `
                                <div class="stats-leader-row ${rankClass}">
                                    <div class="stats-rank">${rank}</div>
                                    <div class="stats-player-info">
                                        <div class="stats-player-name">${player.name}</div>
                                        <div class="stats-player-meta">
                                            <span class="stats-nfl-team">${player.nfl_team}</span>
                                            <span class="stats-fantasy-team">â€¢ ${player.fantasy_team}</span>
                                        </div>
                                    </div>
                                    <div class="stats-points">${player.total_points.toFixed(1)}</div>
                                </div>
                            `;
                        }).join('')}
                        ${currentStatsPosition === 'ALL' && (leaders[pos] || []).length > 5 ? `
                            <button class="stats-view-all" data-pos="${pos}">View all ${positionNames[pos]}</button>
                        ` : ''}
                    </div>
                `;
            }).join('');
            
            // Add click handlers for "view all" buttons
            container.querySelectorAll('.stats-view-all').forEach(btn => {
                btn.addEventListener('click', () => {
                    currentStatsPosition = btn.dataset.pos;
                    renderStatsLeaders();
                });
            });
        }

        function renderTeamStats() {
            const teamStats = data.team_stats;
            if (!teamStats || Object.keys(teamStats).length === 0) {
                document.getElementById('team-stats-container').innerHTML = 
                    '<p style="text-align: center; color: var(--text-muted);">Team stats not available</p>';
                return;
            }
            
            // Sort teams by total points for
            const teams = Object.values(teamStats).sort((a, b) => 
                (b.total_points_for || 0) - (a.total_points_for || 0)
            );
            
            const container = document.getElementById('team-stats-container');
            
            // Build comprehensive stats table
            container.innerHTML = `
                <div class="team-stats-section">
                    <h3>Team Rankings</h3>
                    <div class="stats-table-wrapper">
                        <table class="team-stats-table">
                            <thead>
                                <tr>
                                    <th class="team-col">Team</th>
                                    <th class="num">Record</th>
                                    <th class="num">Win %</th>
                                    <th class="num">PF</th>
                                    <th class="num">PA</th>
                                    <th class="num">Diff</th>
                                    <th class="num">PPG</th>
                                    <th class="num">PPG A</th>
                                    <th class="num">Std Dev</th>
                                    <th class="num">Avg Rank</th>
                                    <th class="num">Best</th>
                                    <th class="num">Worst</th>
                                    <th class="num">Streak</th>
                                    <th class="num">OPR</th>
                                    <th class="num">Adj OPR</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${teams.map((team, index) => {
                                    const winPct = ((team.win_pct || 0) * 100).toFixed(0);
                                    const diff = team.point_differential || 0;
                                    const diffClass = diff > 0 ? 'positive' : diff < 0 ? 'negative' : '';
                                    const streak = team.streak || {};
                                    const streakStr = streak.count ? `${streak.count}${streak.type}` : '-';
                                    const streakClass = streak.type === 'W' ? 'streak-win' : streak.type === 'L' ? 'streak-loss' : '';
                                    
                                    return `
                                        <tr>
                                            <td class="team-col">
                                                <span class="team-abbrev">${team.abbrev}</span>
                                                <span class="team-name-short">${(team.name || '').substring(0, 20)}${(team.name || '').length > 20 ? '...' : ''}</span>
                                            </td>
                                            <td class="num">${team.record || '-'}</td>
                                            <td class="num">${winPct}%</td>
                                            <td class="num">${(team.total_points_for || 0).toFixed(0)}</td>
                                            <td class="num">${(team.total_points_against || 0).toFixed(0)}</td>
                                            <td class="num ${diffClass}">${diff > 0 ? '+' : ''}${diff.toFixed(0)}</td>
                                            <td class="num">${(team.ppg || 0).toFixed(1)}</td>
                                            <td class="num">${(team.ppg_against || 0).toFixed(1)}</td>
                                            <td class="num">${(team.std_dev || 0).toFixed(1)}</td>
                                            <td class="num">${(team.avg_rank || 0).toFixed(1)}</td>
                                            <td class="num">${(team.best_week || 0).toFixed(0)}<span class="week-ref">W${team.best_week_num || '-'}</span></td>
                                            <td class="num">${(team.worst_week || 0).toFixed(0)}<span class="week-ref">W${team.worst_week_num || '-'}</span></td>
                                            <td class="num ${streakClass}">${streakStr}</td>
                                            <td class="num">${(team.opr || 0).toFixed(1)}</td>
                                            <td class="num ${(team.adjusted_opr || 0) >= 1 ? 'positive' : 'negative'}">${(team.adjusted_opr || 0).toFixed(2)}</td>
                                        </tr>
                                    `;
                                }).join('')}
                            </tbody>
                        </table>
                    </div>
                </div>
                
                <div class="team-stats-section">
                    <h3>Advanced Stats</h3>
                    <div class="advanced-stats-grid">
                        <div class="stat-card">
                            <div class="stat-card-title">Most Points (Single Week)</div>
                            ${teams.slice().sort((a, b) => (b.best_week || 0) - (a.best_week || 0)).slice(0, 5).map((t, i) => `
                                <div class="stat-card-row">
                                    <span class="rank">${i + 1}.</span>
                                    <span class="team">${t.abbrev}</span>
                                    <span class="value">${(t.best_week || 0).toFixed(0)}</span>
                                    <span class="context">W${t.best_week_num}</span>
                                </div>
                            `).join('')}
                        </div>
                        
                        <div class="stat-card">
                            <div class="stat-card-title">Fewest Points (Single Week)</div>
                            ${teams.slice().sort((a, b) => (a.worst_week || 999) - (b.worst_week || 999)).slice(0, 5).map((t, i) => `
                                <div class="stat-card-row">
                                    <span class="rank">${i + 1}.</span>
                                    <span class="team">${t.abbrev}</span>
                                    <span class="value">${(t.worst_week || 0).toFixed(0)}</span>
                                    <span class="context">W${t.worst_week_num}</span>
                                </div>
                            `).join('')}
                        </div>
                        
                        <div class="stat-card">
                            <div class="stat-card-title">Highest PPG</div>
                            ${teams.slice().sort((a, b) => (b.ppg || 0) - (a.ppg || 0)).slice(0, 5).map((t, i) => `
                                <div class="stat-card-row">
                                    <span class="rank">${i + 1}.</span>
                                    <span class="team">${t.abbrev}</span>
                                    <span class="value">${(t.ppg || 0).toFixed(1)}</span>
                                </div>
                            `).join('')}
                        </div>
                        
                        <div class="stat-card">
                            <div class="stat-card-title">Fewest PPG Against</div>
                            ${teams.slice().sort((a, b) => (a.ppg_against || 999) - (b.ppg_against || 999)).slice(0, 5).map((t, i) => `
                                <div class="stat-card-row">
                                    <span class="rank">${i + 1}.</span>
                                    <span class="team">${t.abbrev}</span>
                                    <span class="value">${(t.ppg_against || 0).toFixed(1)}</span>
                                </div>
                            `).join('')}
                        </div>
                        
                        <div class="stat-card">
                            <div class="stat-card-title">Largest Win Margin</div>
                            ${teams.slice().sort((a, b) => (b.largest_win || 0) - (a.largest_win || 0)).slice(0, 5).map((t, i) => `
                                <div class="stat-card-row">
                                    <span class="rank">${i + 1}.</span>
                                    <span class="team">${t.abbrev}</span>
                                    <span class="value">+${(t.largest_win || 0).toFixed(0)}</span>
                                </div>
                            `).join('')}
                        </div>
                        
                        <div class="stat-card">
                            <div class="stat-card-title">Most Consistent (Low Std Dev)</div>
                            ${teams.slice().sort((a, b) => (a.std_dev || 999) - (b.std_dev || 999)).slice(0, 5).map((t, i) => `
                                <div class="stat-card-row">
                                    <span class="rank">${i + 1}.</span>
                                    <span class="team">${t.abbrev}</span>
                                    <span class="value">Ïƒ ${(t.std_dev || 0).toFixed(1)}</span>
                                </div>
                            `).join('')}
                        </div>
                        
                        <div class="stat-card">
                            <div class="stat-card-title">Best Avg Weekly Rank</div>
                            ${teams.slice().sort((a, b) => (a.avg_rank || 999) - (b.avg_rank || 999)).slice(0, 5).map((t, i) => `
                                <div class="stat-card-row">
                                    <span class="rank">${i + 1}.</span>
                                    <span class="team">${t.abbrev}</span>
                                    <span class="value">${(t.avg_rank || 0).toFixed(2)}</span>
                                </div>
                            `).join('')}
                        </div>
                        
                        <div class="stat-card">
                            <div class="stat-card-title">Point Differential</div>
                            ${teams.slice().sort((a, b) => (b.point_differential || 0) - (a.point_differential || 0)).slice(0, 5).map((t, i) => {
                                const diff = t.point_differential || 0;
                                return `
                                    <div class="stat-card-row">
                                        <span class="rank">${i + 1}.</span>
                                        <span class="team">${t.abbrev}</span>
                                        <span class="value ${diff > 0 ? 'positive' : 'negative'}">${diff > 0 ? '+' : ''}${diff.toFixed(0)}</span>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                        
                        <div class="stat-card">
                            <div class="stat-card-title">OPR (Owner Performance Rating)</div>
                            ${teams.slice().sort((a, b) => (b.opr || 0) - (a.opr || 0)).slice(0, 5).map((t, i) => `
                                <div class="stat-card-row">
                                    <span class="rank">${i + 1}.</span>
                                    <span class="team">${t.abbrev}</span>
                                    <span class="value">${(t.opr || 0).toFixed(1)}</span>
                                </div>
                            `).join('')}
                        </div>
                        
                        <div class="stat-card">
                            <div class="stat-card-title">Adjusted OPR (vs League Avg)</div>
                            ${teams.slice().sort((a, b) => (b.adjusted_opr || 0) - (a.adjusted_opr || 0)).slice(0, 5).map((t, i) => `
                                <div class="stat-card-row">
                                    <span class="rank">${i + 1}.</span>
                                    <span class="team">${t.abbrev}</span>
                                    <span class="value ${(t.adjusted_opr || 0) >= 1 ? 'positive' : ''}">${(t.adjusted_opr || 0).toFixed(2)}</span>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                </div>
                <div class="formula-section">
                    <div class="formula-note">
                        <strong>OPR Formula:</strong> (5 Ã— PPG + 2 Ã— (Best Week + Worst Week) + 3 Ã— Win%) / 10
                    </div>
                    <div class="formula-note">
                        <strong>Adjusted OPR:</strong> Team OPR / League Average OPR
                    </div>
                </div>
            `;
        }

        function renderConstitution() {
            if (!data.constitution) return;
            
            const container = document.getElementById('constitution-container');
            
            // Number items within each section
            container.innerHTML = data.constitution.map(article => `
                <div class="constitution-article">
                    <div class="article-title">${article.title}</div>
                    ${article.sections.map(section => {
                        let itemNum = 0;
                        let subItemLetter = 'a';
                        return `
                            <div class="article-section">
                                <div class="section-title">${section.title}</div>
                                <div class="section-content">
                                    ${section.content.map(item => {
                                        if (item.type === 'subheader') {
                                            return `<div class="section-subheader">${item.text}</div>`;
                                        } else if (item.type === 'header') {
                                            itemNum = 0;
                                            subItemLetter = 'a';
                                            return `<div class="content-header">${item.text}</div>`;
                                        } else if (item.type === 'item') {
                                            itemNum++;
                                            subItemLetter = 'a';
                                            return `<div class="content-item"><span class="item-num">${itemNum}.</span> ${item.text}</div>`;
                                        } else if (item.type === 'subitem') {
                                            const letter = subItemLetter;
                                            subItemLetter = String.fromCharCode(subItemLetter.charCodeAt(0) + 1);
                                            return `<div class="content-subitem"><span class="item-num">${letter}.</span> ${item.text}</div>`;
                                        }
                                        return `<p>${item.text}</p>`;
                                    }).join('')}
                                </div>
                            </div>
                        `;
                    }).join('')}
                </div>
            `).join('');
        }

        // Lineup Form State
        const LINEUP_CONFIG = {
            // Use current host for API calls (works on both preview and production)
            workerUrl: window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1'
                ? 'https://scoring-henna.vercel.app/api/lineup'  // Fallback for local dev
                : `${window.location.origin}/api/lineup`,
            positions: {
                'QB': { max: 1, label: 'Quarterback' },
                'RB': { max: 2, label: 'Running Back' },
                'WR': { max: 2, label: 'Wide Receiver' },
                'TE': { max: 1, label: 'Tight End' },
                'K': { max: 1, label: 'Kicker' },
                'D/ST': { max: 1, label: 'Defense/ST' },
                'HC': { max: 1, label: 'Head Coach' },
                'OL': { max: 1, label: 'Offensive Line' }
            }
        };
        
        let lineupState = {
            team: null,
            week: null,
            roster: [],
            selections: {} // position -> [player names]
        };

        function initLineupForm() {
            // Populate current team name in the input
            const canonicalTeam = data.teams?.find(t => t.abbrev === manageState.team);
            const teamNameInput = document.getElementById('new-team-name');
            if (teamNameInput && canonicalTeam) {
                teamNameInput.value = canonicalTeam.name;
            }
            
            // Set up team name change button
            document.getElementById('change-team-name-btn').onclick = handleTeamNameChange;
            
            const weekSelect = document.getElementById('lineup-week-select');
            
            // Collect all weeks - regular season from data.weeks plus playoff weeks from schedule
            const allWeeks = new Set();
            if (data && data.weeks) {
                data.weeks.forEach(w => allWeeks.add(w.week));
            }
            // Add playoff weeks from schedule
            if (data && data.schedule) {
                data.schedule.forEach(w => {
                    if (w.is_playoffs) allWeeks.add(w.week);
                });
            }
            
            const weekNumbers = Array.from(allWeeks).sort((a, b) => a - b);
            const playoffWeeks = new Set((data?.schedule || []).filter(w => w.is_playoffs).map(w => w.week));
            
            weekSelect.innerHTML = '<option value="">-- Select Week --</option>' +
                weekNumbers.map(w => {
                    const isPlayoff = playoffWeeks.has(w);
                    const scheduleWeek = data.schedule?.find(sw => sw.week === w);
                    const label = isPlayoff && scheduleWeek?.playoff_round 
                        ? `Week ${w} - ${scheduleWeek.playoff_round}`
                        : `Week ${w}`;
                    return `<option value="${w}"${w === data.current_week ? ' selected' : ''}>${label}</option>`;
                }).join('');
            
            // Event listener for week change
            weekSelect.onchange = loadRosterForEditing;
            document.getElementById('lineup-submit-btn').onclick = submitLineup;
            
            // If current week is preselected, load the roster
            if (weekSelect.value) {
                loadRosterForEditing();
            }
        }

        async function loadRosterForEditing() {
            const week = parseInt(document.getElementById('lineup-week-select').value);
            const teamAbbrev = manageState.team;
            const password = manageState.password;
            
            if (!week) {
                document.getElementById('lineup-editor').style.display = 'none';
                return;
            }
            
            // Find the team's roster for this week - check regular weeks first
            const weekData = data.weeks.find(w => w.week === week);
            const scheduleWeek = data.schedule?.find(w => w.week === week);
            const isPlayoffWeek = scheduleWeek?.is_playoffs;
            
            let teamData = null;
            let roster = [];
            
            if (weekData && weekData.matchups) {
                // Regular week - get roster from matchup data
                for (const matchup of weekData.matchups) {
                    if (matchup.team1.abbrev === teamAbbrev) {
                        teamData = matchup.team1;
                        break;
                    }
                    if (matchup.team2.abbrev === teamAbbrev) {
                        teamData = matchup.team2;
                        break;
                    }
                }
                if (teamData) {
                    roster = teamData.roster;
                }
            }
            
            // For playoff weeks (or any week without roster data), use the roster from the most recent regular season week
            if (roster.length === 0) {
                // Find the most recent week with this team's roster data
                const sortedWeeks = [...data.weeks].sort((a, b) => b.week - a.week);
                for (const w of sortedWeeks) {
                    if (w.matchups) {
                        for (const matchup of w.matchups) {
                            if (matchup.team1.abbrev === teamAbbrev && matchup.team1.roster?.length > 0) {
                                roster = matchup.team1.roster.map(p => ({
                                    name: p.name,
                                    nfl_team: p.nfl_team,
                                    position: p.position,
                                    score: 0,
                                    starter: false  // Reset starters for new week
                                }));
                                break;
                            }
                            if (matchup.team2.abbrev === teamAbbrev && matchup.team2.roster?.length > 0) {
                                roster = matchup.team2.roster.map(p => ({
                                    name: p.name,
                                    nfl_team: p.nfl_team,
                                    position: p.position,
                                    score: 0,
                                    starter: false
                                }));
                                break;
                            }
                        }
                    }
                    if (roster.length > 0) break;
                }
            }
            
            if (roster.length === 0) {
                document.getElementById('submit-status').className = 'submit-status error';
                document.getElementById('submit-status').textContent = 'No roster data available for this week';
                document.getElementById('lineup-editor').style.display = 'none';
                return;
            }
            
            // Store state
            const canonicalTeam = data.teams?.find(t => t.abbrev === teamAbbrev);
            lineupState.team = teamAbbrev;
            lineupState.teamName = canonicalTeam?.name || teamAbbrev;
            lineupState.week = week;
            lineupState.password = password;
            lineupState.roster = roster;
            lineupState.selections = {};
            
            // Initialize selections based on current starters
            Object.keys(LINEUP_CONFIG.positions).forEach(pos => {
                lineupState.selections[pos] = roster
                    .filter(p => p.position === pos && p.starter)
                    .map(p => p.name);
            });
            
            // Show editor
            document.getElementById('lineup-editor').style.display = 'block';
            const weekLabel = isPlayoffWeek && scheduleWeek?.playoff_round
                ? `${scheduleWeek.playoff_round}`
                : `Week ${week}`;
            document.getElementById('editor-week-label').textContent = weekLabel;
            document.getElementById('submit-status').textContent = '';
            document.getElementById('submit-status').className = 'submit-status';
            
            renderLineupEditor();
        }

        function resetLineupForm() {
            document.getElementById('lineup-editor').style.display = 'none';
            document.getElementById('submit-status').textContent = '';
            document.getElementById('submit-status').className = 'submit-status';
            document.getElementById('lineup-week-select').value = '';
            lineupState = { team: null, week: null, roster: [], selections: {} };
        }

        function renderLineupEditor() {
            const container = document.getElementById('position-groups');
            const positions = Object.keys(LINEUP_CONFIG.positions);
            const lockedPlayers = getLockedPlayers();
            
            container.innerHTML = positions.map(pos => {
                const config = LINEUP_CONFIG.positions[pos];
                const players = lineupState.roster.filter(p => p.position === pos);
                const selected = lineupState.selections[pos] || [];
                const isFull = selected.length === config.max;
                const countClass = isFull ? 'complete' : '';
                
                return `
                    <div class="position-group-card">
                        <div class="position-group-header">
                            <span class="position-label">${pos} - ${config.label}</span>
                            <span class="starter-count ${countClass}">${selected.length}/${config.max} starting</span>
                        </div>
                        <div class="player-options">
                            ${players.map(p => {
                                const isSelected = selected.includes(p.name);
                                const isLocked = lockedPlayers.has(p.name);
                                const classes = [
                                    'player-option',
                                    isSelected ? 'selected' : '',
                                    isLocked ? 'locked' : ''
                                ].filter(Boolean).join(' ');
                                
                                return `
                                    <div class="${classes}" 
                                         data-position="${pos}" data-player="${p.name}" data-locked="${isLocked}">
                                        <div class="starter-indicator">${isLocked ? 'ðŸ”’' : ''}</div>
                                        <div class="player-details">
                                            <span class="player-name">${p.name}</span>
                                            <span class="player-team">${p.nfl_team}</span>
                                            ${isLocked ? '<span class="locked-label">LOCKED</span>' : ''}
                                        </div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                `;
            }).join('');
            
            // Add click handlers (only for unlocked players)
            container.querySelectorAll('.player-option').forEach(el => {
                el.addEventListener('click', () => {
                    if (el.dataset.locked === 'true') {
                        // Show message that player is locked
                        const statusEl = document.getElementById('submit-status');
                        statusEl.className = 'submit-status error';
                        statusEl.textContent = `${el.dataset.player}'s game has already started - lineup locked`;
                        setTimeout(() => { statusEl.textContent = ''; statusEl.className = 'submit-status'; }, 3000);
                        return;
                    }
                    const pos = el.dataset.position;
                    const player = el.dataset.player;
                    togglePlayerSelection(pos, player);
                });
            });
            
            updateLineupSummary();
        }

        function togglePlayerSelection(position, playerName) {
            const config = LINEUP_CONFIG.positions[position];
            const selected = lineupState.selections[position] || [];
            
            if (selected.includes(playerName)) {
                // Deselect - always allowed
                lineupState.selections[position] = selected.filter(p => p !== playerName);
            } else {
                // Select (if under max limit)
                if (selected.length < config.max) {
                    lineupState.selections[position] = [...selected, playerName];
                }
                // At max - do nothing (user must deselect first)
            }
            
            renderLineupEditor();
        }

        function updateLineupSummary() {
            const summary = document.getElementById('lineup-summary');
            const submitBtn = document.getElementById('lineup-submit-btn');
            
            let total = 0;
            let maxTotal = 0;
            Object.keys(LINEUP_CONFIG.positions).forEach(pos => {
                const config = LINEUP_CONFIG.positions[pos];
                const selected = (lineupState.selections[pos] || []).length;
                total += selected;
                maxTotal += config.max;
            });
            
            // Always valid - users can start 0 to max players
            summary.textContent = `${total} starters selected (max ${maxTotal})`;
            summary.className = 'lineup-summary valid';
            submitBtn.disabled = false;
        }

        function isPlayerLocked(player) {
            // Check if player's game has started based on game_times data
            // JSON keys are strings, so convert week to string
            const weekKey = String(lineupState.week);
            if (!data.game_times || !data.game_times[weekKey]) {
                console.log('No game times for week', weekKey);
                return false;
            }
            
            const gameTimes = data.game_times[weekKey];
            const playerTeam = player.nfl_team;
            const gameTime = gameTimes[playerTeam];
            
            if (!gameTime) {
                console.log('No game time for team', playerTeam);
                return false;
            }
            
            const kickoff = new Date(gameTime);
            const now = new Date();
            const isLocked = now >= kickoff;
            
            // Debug logging
            if (player.name.includes('Campbell') || player.name.includes('Lamb')) {
                console.log(`${player.name} (${playerTeam}): kickoff=${gameTime}, now=${now.toISOString()}, locked=${isLocked}`);
            }
            
            return isLocked;
        }

        function getLockedPlayers() {
            // Returns set of player names that are locked
            const locked = new Set();
            lineupState.roster.forEach(player => {
                if (isPlayerLocked(player)) {
                    locked.add(player.name);
                }
            });
            return locked;
        }

        async function handleTeamNameChange() {
            const newName = document.getElementById('new-team-name').value.trim();
            const statusEl = document.getElementById('team-name-status');
            
            if (!newName) {
                statusEl.innerHTML = '<span class="error">Please enter a team name</span>';
                return;
            }
            
            if (newName.length > 50) {
                statusEl.innerHTML = '<span class="error">Team name must be 50 characters or less</span>';
                return;
            }
            
            statusEl.innerHTML = '<span class="pending">Updating team name...</span>';
            
            try {
                // Create the team name change request
                const response = await fetch(LINEUP_CONFIG.workerUrl.replace('/lineup', '/team-name'), {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        team: manageState.team,
                        password: manageState.password,
                        newName: newName,
                        week: data.current_week
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    statusEl.innerHTML = '<span class="success">Team name updated! Changes will appear after the next data refresh.</span>';
                    
                    // Update the display immediately
                    document.getElementById('manage-team-name').textContent = newName;
                    
                    // Update local data
                    const teamData = data.teams?.find(t => t.abbrev === manageState.team);
                    if (teamData) {
                        teamData.name = newName;
                    }
                    
                    // Clear status after a few seconds
                    setTimeout(() => {
                        statusEl.innerHTML = '';
                    }, 5000);
                } else {
                    statusEl.innerHTML = `<span class="error">${result.error || 'Failed to update team name'}</span>`;
                }
            } catch (e) {
                console.error('Team name change error:', e);
                statusEl.innerHTML = '<span class="error">Network error - please try again</span>';
            }
        }

        async function submitLineup() {
            const statusEl = document.getElementById('submit-status');
            const submitBtn = document.getElementById('lineup-submit-btn');
            
            // Check for localhost
            if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
                statusEl.className = 'submit-status error';
                statusEl.textContent = 'Lineup submission only works on the deployed site (Vercel). Local testing shows the UI only.';
                return;
            }
            
            statusEl.className = 'submit-status loading';
            statusEl.textContent = 'Submitting lineup...';
            submitBtn.disabled = true;
            
            // Get currently locked players (games already started)
            const lockedPlayers = getLockedPlayers();
            
            // Get optional comment
            const commentEl = document.getElementById('lineup-comment');
            const comment = commentEl ? commentEl.value.trim() : '';
            
            const payload = {
                team: lineupState.team,
                week: lineupState.week,
                password: lineupState.password,
                starters: lineupState.selections,
                locked_players: Array.from(lockedPlayers),
                comment: comment,
                submitted_at: new Date().toISOString()
            };
            
            try {
                const response = await fetch(LINEUP_CONFIG.workerUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                const result = await response.json();
                
                if (response.ok && result.success) {
                    statusEl.className = 'submit-status success';
                    statusEl.textContent = 'âœ“ Lineup submitted successfully! Changes will be reflected after the next update.';
                } else {
                    statusEl.className = 'submit-status error';
                    statusEl.textContent = result.error || 'Failed to submit lineup';
                    submitBtn.disabled = false;
                }
            } catch (error) {
                statusEl.className = 'submit-status error';
                statusEl.textContent = 'Network error - please try again. Make sure you are on the deployed site.';
                submitBtn.disabled = false;
            }
        }

        // Navigation
        document.querySelectorAll('.nav-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.nav-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                
                document.querySelectorAll('.view-container').forEach(v => v.classList.remove('active'));
                document.getElementById(`${btn.dataset.view}-view`).classList.add('active');
                
                // Initialize manage roster when navigating to it
                if (btn.dataset.view === 'manage') {
                    initManageRoster();
                }
            });
        });

        // Hall of Fame sub-navigation
        document.querySelectorAll('.hof-subnav-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                // Update active button
                document.querySelectorAll('.hof-subnav-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                
                // Show correct subview
                document.querySelectorAll('.hof-subview').forEach(v => v.classList.remove('active'));
                document.getElementById(`hof-${btn.dataset.subview}-subview`).classList.add('active');
            });
        });

        // Team sub-navigation
        document.querySelectorAll('.team-subnav-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                // Update active button
                document.querySelectorAll('.team-subnav-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
                
                // Show correct subview
                document.querySelectorAll('.team-subview').forEach(v => v.classList.remove('active'));
                document.getElementById(`team-${btn.dataset.subview}-subview`).classList.add('active');
                
                // Render Team HOF if switching to that tab
                if (btn.dataset.subview === 'hof') {
                    renderTeamHof();
                }
                // Render Trade Block if switching to that tab
                if (btn.dataset.subview === 'tradeblock') {
                    renderTeamTradeBlock();
                }
            });
        });

        // ====== MANAGE ROSTER SECTION ======
        const MANAGE_CONFIG = {
            // Use current host for API calls (works on both preview and production)
            apiUrl: window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1'
                ? 'https://scoring-henna.vercel.app/api/transaction'  // Fallback for local dev
                : `${window.location.origin}/api/transaction`
        };

        let manageState = {
            team: null,
            password: null,
            selectedTaxiPlayer: null,
            selectedReleasePlayer: null,
            selectedFaPlayer: null,
            selectedFaReleasePlayer: null,
            tradeGivePlayers: [],
            tradeGivePicks: [],
            tradeReceivePlayers: [],
            tradeReceivePicks: [],
            tradeConditions: {}, // { itemId: conditionText }
            tradePartner: null
        };

        function initManageRoster() {
            const teamSelect = document.getElementById('manage-team-select');
            teamSelect.innerHTML = '<option value="">-- Choose Team --</option>';
            
            // Get teams from data.teams (offseason) or latest week (during season)
            let teams = [];
            if (data && data.teams && data.teams.length > 0) {
                // Use data.teams directly (works for offseason and during season)
                teams = data.teams;
            } else if (data && data.weeks && data.weeks.length > 0) {
                // Fallback to latest week's teams
                const latestWeek = data.weeks.reduce((max, week) => 
                    (week.week > max.week) ? week : max, data.weeks[0]);
                teams = latestWeek.teams || [];
            }
            
            teams.forEach(team => {
                const option = document.createElement('option');
                option.value = team.abbrev;
                option.textContent = `${team.name} (${team.abbrev})`;
                teamSelect.appendChild(option);
            });
            
            // Reset state
            resetManageState();
            resetLineupForm();
            document.getElementById('manage-auth').style.display = 'block';
            document.getElementById('manage-panel').style.display = 'none';
            document.getElementById('manage-error').textContent = '';
            
            // Set up event listeners
            document.getElementById('manage-login-btn').onclick = handleManageLogin;
            document.getElementById('manage-logout-btn').onclick = handleManageLogout;
            
            // Set up tab switching
            document.querySelectorAll('.tx-tab').forEach(tab => {
                tab.onclick = () => switchTxTab(tab.dataset.tab);
            });
            
            // Reset to first tab (lineup)
            switchTxTab('lineup');
        }

        function resetManageState() {
            manageState = {
                team: null,
                password: null,
                selectedTaxiPlayer: null,
                selectedReleasePlayer: null,
                selectedFaPlayer: null,
                selectedFaReleasePlayer: null,
                tradeGivePlayers: [],
                tradeGivePicks: [],
                tradeReceivePlayers: [],
                tradeReceivePicks: [],
                tradeConditions: {},
                tradePartner: null
            };
        }

        async function handleManageLogin() {
            const team = document.getElementById('manage-team-select').value;
            const password = document.getElementById('manage-password').value;
            const errorEl = document.getElementById('manage-error');
            
            if (!team || !password) {
                errorEl.textContent = 'Please select a team and enter password';
                return;
            }
            
            errorEl.textContent = 'Validating...';
            
            try {
                const response = await fetch(MANAGE_CONFIG.apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ action: 'validate', team, password })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    manageState.team = team;
                    manageState.password = password;
                    
                    document.getElementById('manage-auth').style.display = 'none';
                    document.getElementById('manage-panel').style.display = 'block';
                    
                    // Use canonical team name from data.teams
                    const canonicalTeam = data.teams?.find(t => t.abbrev === team);
                    document.getElementById('manage-team-name').textContent = canonicalTeam?.name || team;
                    
                    // Initialize lineup form and other tabs
                    initLineupForm();
                    renderTaxiTab();
                    renderFaTab();
                    renderTradeTab();
                    renderPendingTrades();
                } else {
                    errorEl.textContent = result.error || 'Invalid password';
                }
            } catch (e) {
                console.error('Login error:', e);
                // Allow localhost testing without API validation
                if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
                    manageState.team = team;
                    manageState.password = password;
                    
                    document.getElementById('manage-auth').style.display = 'none';
                    document.getElementById('manage-panel').style.display = 'block';
                    
                    const canonicalTeam = data.teams?.find(t => t.abbrev === team);
                    document.getElementById('manage-team-name').textContent = canonicalTeam?.name || team;
                    
                    initLineupForm();
                    renderTaxiTab();
                    renderFaTab();
                    renderTradeTab();
                    renderPendingTrades();
                    errorEl.textContent = '';
                } else {
                    errorEl.textContent = 'Network error - please try again';
                }
            }
        }

        function handleManageLogout() {
            resetManageState();
            resetLineupForm();
            document.getElementById('manage-auth').style.display = 'block';
            document.getElementById('manage-panel').style.display = 'none';
            document.getElementById('manage-password').value = '';
            // Reset to first tab (lineup)
            switchTxTab('lineup');
        }

        function switchTxTab(tabName) {
            document.querySelectorAll('.tx-tab').forEach(t => t.classList.remove('active'));
            document.querySelector(`.tx-tab[data-tab="${tabName}"]`).classList.add('active');
            
            document.querySelectorAll('.tx-content').forEach(c => c.classList.remove('active'));
            document.getElementById(`tx-${tabName}`).classList.add('active');
            
            // Initialize trade block tab when switching to it
            if (tabName === 'tradeblock') {
                renderTradeBlockTab();
            }
        }

        function getTeamData(abbrev) {
            if (!data) return null;
            
            // Prefer data.rosters (updated by transactions) over weekly roster data
            // data.rosters format: { "GSA": [{name, nfl_team, position}, ...], ... }
            if (data.rosters && data.rosters[abbrev]) {
                const rosterArray = data.rosters[abbrev];
                // Get team name from data.teams or standings
                const teamInfo = data.teams?.find(t => t.abbrev === abbrev) || 
                                 data.standings?.find(t => t.abbrev === abbrev) || {};
                return {
                    abbrev: abbrev,
                    name: teamInfo.name || abbrev,
                    owner: teamInfo.owner || '',
                    roster: rosterArray,
                    taxi_squad: []  // Taxi squad not in rosters format, empty in offseason anyway
                };
            }
            
            // Fallback to weekly roster data
            if (!data.weeks || data.weeks.length === 0) return null;
            
            // Find the highest week number (weeks may not be sorted numerically)
            const latestWeek = data.weeks.reduce((max, week) => 
                (week.week > max.week) ? week : max, data.weeks[0]);
            
            if (!latestWeek || !latestWeek.teams) return null;
            const teamData = latestWeek.teams.find(t => t.abbrev === abbrev);
            
            // During offseason (after week 17), taxi squads are empty
            if (teamData && (data.current_week > 17)) {
                teamData.taxi_squad = [];
            }
            
            return teamData;
        }

        function renderTaxiTab() {
            const teamData = getTeamData(manageState.team);
            if (!teamData) return;
            
            const taxiList = document.getElementById('taxi-players');
            const taxiSquad = teamData.taxi_squad || [];
            
            if (taxiSquad.length === 0) {
                taxiList.innerHTML = '<p class="no-pending-trades">No players on taxi squad</p>';
                return;
            }
            
            taxiList.innerHTML = taxiSquad.map(player => `
                <div class="tx-player" data-name="${player.name}" data-position="${player.position}">
                    <span class="position-tag">${player.position}</span>
                    <span class="player-name">${player.name}</span>
                    <span class="player-team">${player.nfl_team}</span>
                </div>
            `).join('');
            
            // Add click handlers
            taxiList.querySelectorAll('.tx-player').forEach(el => {
                el.onclick = () => selectTaxiPlayer(el.dataset.name, el.dataset.position);
            });
            
            document.getElementById('taxi-release-section').style.display = 'none';
            document.getElementById('taxi-actions').style.display = 'none';
            
            // Set up submit handler
            document.getElementById('taxi-submit-btn').onclick = submitTaxiActivation;
        }

        function selectTaxiPlayer(name, position) {
            // Clear previous selection
            document.querySelectorAll('#taxi-players .tx-player').forEach(el => el.classList.remove('selected'));
            
            // Select new player
            const selected = document.querySelector(`#taxi-players .tx-player[data-name="${name}"]`);
            if (selected) selected.classList.add('selected');
            
            manageState.selectedTaxiPlayer = { name, position };
            manageState.selectedReleasePlayer = null;
            
            // Show release options
            renderTaxiReleaseOptions(position);
        }

        function renderTaxiReleaseOptions(position) {
            const teamData = getTeamData(manageState.team);
            const roster = teamData.roster.filter(p => p.position === position);
            
            const releaseSection = document.getElementById('taxi-release-section');
            const releaseList = document.getElementById('taxi-release-players');
            
            if (roster.length === 0) {
                releaseList.innerHTML = `<p>No ${position} players on active roster to release</p>`;
            } else {
                releaseList.innerHTML = roster.map(player => `
                    <div class="tx-player" data-name="${player.name}">
                        <span class="position-tag">${player.position}</span>
                        <span class="player-name">${player.name}</span>
                        <span class="player-team">${player.nfl_team}</span>
                    </div>
                `).join('');
                
                releaseList.querySelectorAll('.tx-player').forEach(el => {
                    el.onclick = () => selectTaxiReleasePlayer(el.dataset.name);
                });
            }
            
            releaseSection.style.display = 'block';
        }

        function selectTaxiReleasePlayer(name) {
            document.querySelectorAll('#taxi-release-players .tx-player').forEach(el => el.classList.remove('selected'));
            document.querySelector(`#taxi-release-players .tx-player[data-name="${name}"]`).classList.add('selected');
            
            manageState.selectedReleasePlayer = name;
            
            // Show actions
            document.getElementById('taxi-actions').style.display = 'flex';
            document.getElementById('taxi-summary').textContent = 
                `Activate ${manageState.selectedTaxiPlayer.name} â†’ Release ${name}`;
        }

        async function submitTaxiActivation() {
            const statusEl = document.getElementById('taxi-status');
            statusEl.className = 'submit-status loading';
            statusEl.textContent = 'Processing...';
            
            // Get optional comment
            const commentEl = document.getElementById('taxi-comment');
            const comment = commentEl ? commentEl.value.trim() : '';
            
            try {
                const response = await fetch(MANAGE_CONFIG.apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        action: 'taxi_activate',
                        team: manageState.team,
                        password: manageState.password,
                        player_to_activate: manageState.selectedTaxiPlayer.name,
                        player_to_release: manageState.selectedReleasePlayer,
                        week: data.current_week,
                        comment: comment,
                        submitted_at: new Date().toISOString()
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    statusEl.className = 'submit-status success';
                    statusEl.textContent = result.message;
                    // Reload data
                    setTimeout(() => loadData(), 2000);
                } else {
                    statusEl.className = 'submit-status error';
                    statusEl.textContent = result.error;
                }
            } catch (e) {
                statusEl.className = 'submit-status error';
                statusEl.textContent = 'Network error - please try again';
            }
        }

        function renderFaTab() {
            const faList = document.getElementById('fa-players');
            const faPool = data.fa_pool || [];
            
            if (faPool.length === 0) {
                faList.innerHTML = '<p class="no-pending-trades">No players in FA pool</p>';
                return;
            }
            
            // Get players who have already been picked up from transaction log
            const pickedUpPlayers = new Set();
            // Check transaction_log structure (from data/transaction_log.json via legacy export)
            if (data.transaction_log && data.transaction_log.transactions) {
                for (const txn of data.transaction_log.transactions) {
                    if ((txn.type === 'fa_activation' || txn.type === 'taxi_activation') && txn.added) {
                        pickedUpPlayers.add(txn.added.toLowerCase());
                    }
                }
            }
            // Also check the transactions display structure for FA pool text mentions
            // Only check the current season's transactions
            if (data.transactions && Array.isArray(data.transactions)) {
                const currentSeasonTxns = data.transactions.find(s => 
                    s.season === `${currentSeason} Season` || s.season === String(currentSeason)
                );
                if (currentSeasonTxns) {
                    for (const week of (currentSeasonTxns.weeks || [])) {
                        for (const txn of (week.transactions || [])) {
                            for (const item of (txn.items || [])) {
                                if (item.text && item.text.includes('from FA Pool')) {
                                    // Extract player name: "Add/Added PLAYER from FA Pool"
                                    const match = item.text.match(/Add(?:ed)? (?:(?:QB|RB|WR|TE|K|D\/ST) )?(.+?) (?:\(.+?\) )?from FA Pool/i);
                                    if (match) {
                                        pickedUpPlayers.add(match[1].toLowerCase());
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            // Filter out players who have been picked up
            const availablePlayers = faPool.filter(player => {
                const isTaken = player.available === false || pickedUpPlayers.has(player.name.toLowerCase());
                return !isTaken;
            });
            
            if (availablePlayers.length === 0) {
                faList.innerHTML = '<p class="no-pending-trades">All FA pool players have been claimed</p>';
                return;
            }
            
            faList.innerHTML = availablePlayers.map(player => `
                <div class="tx-player" 
                     data-name="${player.name}" data-position="${player.position}">
                    <span class="position-tag">${player.position}</span>
                    <span class="player-name">${player.name}</span>
                    <span class="player-team">${player.nfl_team}</span>
                </div>
            `).join('');
            
            // Add click handlers only for available players
            faList.querySelectorAll('.tx-player:not(.unavailable)').forEach(el => {
                el.onclick = () => selectFaPlayer(el.dataset.name, el.dataset.position);
            });
            
            document.getElementById('fa-release-section').style.display = 'none';
            document.getElementById('fa-actions').style.display = 'none';
            
            document.getElementById('fa-submit-btn').onclick = submitFaActivation;
        }

        function selectFaPlayer(name, position) {
            document.querySelectorAll('#fa-players .tx-player').forEach(el => el.classList.remove('selected'));
            document.querySelector(`#fa-players .tx-player[data-name="${name}"]`).classList.add('selected');
            
            manageState.selectedFaPlayer = { name, position };
            manageState.selectedFaReleasePlayer = null;
            
            renderFaReleaseOptions(position);
        }

        function renderFaReleaseOptions(position) {
            const teamData = getTeamData(manageState.team);
            const roster = teamData.roster.filter(p => p.position === position);
            
            const releaseSection = document.getElementById('fa-release-section');
            const releaseList = document.getElementById('fa-release-players');
            
            if (roster.length === 0) {
                releaseList.innerHTML = `<p>No ${position} players on active roster to release</p>`;
            } else {
                releaseList.innerHTML = roster.map(player => `
                    <div class="tx-player" data-name="${player.name}">
                        <span class="position-tag">${player.position}</span>
                        <span class="player-name">${player.name}</span>
                        <span class="player-team">${player.nfl_team}</span>
                    </div>
                `).join('');
                
                releaseList.querySelectorAll('.tx-player').forEach(el => {
                    el.onclick = () => selectFaReleasePlayer(el.dataset.name);
                });
            }
            
            releaseSection.style.display = 'block';
        }

        function selectFaReleasePlayer(name) {
            document.querySelectorAll('#fa-release-players .tx-player').forEach(el => el.classList.remove('selected'));
            document.querySelector(`#fa-release-players .tx-player[data-name="${name}"]`).classList.add('selected');
            
            manageState.selectedFaReleasePlayer = name;
            
            document.getElementById('fa-actions').style.display = 'flex';
            document.getElementById('fa-summary').textContent = 
                `Add ${manageState.selectedFaPlayer.name} â†’ Release ${name}`;
        }

        async function submitFaActivation() {
            const statusEl = document.getElementById('fa-status');
            statusEl.className = 'submit-status loading';
            statusEl.textContent = 'Processing...';
            
            // Get optional comment
            const commentEl = document.getElementById('fa-comment');
            const comment = commentEl ? commentEl.value.trim() : '';
            
            try {
                const response = await fetch(MANAGE_CONFIG.apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        action: 'fa_activate',
                        team: manageState.team,
                        password: manageState.password,
                        player_to_add: manageState.selectedFaPlayer.name,
                        player_to_release: manageState.selectedFaReleasePlayer,
                        week: data.current_week,
                        comment: comment,
                        submitted_at: new Date().toISOString()
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    statusEl.className = 'submit-status success';
                    statusEl.textContent = result.message;
                    setTimeout(() => loadData(), 2000);
                } else {
                    statusEl.className = 'submit-status error';
                    statusEl.textContent = result.error;
                }
            } catch (e) {
                statusEl.className = 'submit-status error';
                statusEl.textContent = 'Network error - please try again';
            }
        }

        function renderTradeTab() {
            // Trade deadline logic:
            // - Before week 12: Trading open
            // - Week 12 Thursday through week 17: Trading blocked (deadline period)
            // - Week 18+ (offseason): Trading open
            const deadlineWarning = document.getElementById('trade-deadline-warning');
            const tradeDeadline = data.trade_deadline_week || 12;
            const isOffseason = data.current_week > 17;  // Week 18+ is offseason
            const isDeadlinePeriod = data.current_week >= tradeDeadline && data.current_week <= 17;
            
            // Reset classes
            deadlineWarning.classList.remove('trading-open', 'trading-blocked', 'trading-normal');
            
            if (isOffseason) {
                // Offseason - trading is open
                deadlineWarning.textContent = 'Offseason trading is open';
                deadlineWarning.classList.add('trading-open');
                document.getElementById('trade-submit-btn').disabled = false;
            } else if (isDeadlinePeriod) {
                deadlineWarning.textContent = `Trade deadline has passed (Week ${tradeDeadline})`;
                deadlineWarning.classList.add('trading-blocked');
                document.getElementById('trade-submit-btn').disabled = true;
            } else {
                deadlineWarning.textContent = `Trade deadline: Week ${tradeDeadline}`;
                deadlineWarning.classList.add('trading-normal');
                document.getElementById('trade-submit-btn').disabled = false;
            }
            
            // Populate trade partner select
            const partnerSelect = document.getElementById('trade-partner-select');
            partnerSelect.innerHTML = '<option value="">-- Select Team --</option>';
            
            // Get teams list - prefer from latest week, fall back to data.teams for offseason
            let teams = [];
            if (data.weeks && data.weeks.length > 0) {
                const latestWeek = data.weeks.reduce((max, week) => 
                    (week.week > max.week) ? week : max, data.weeks[0]);
                teams = latestWeek.teams || [];
            }
            // Fall back to data.teams (for offseason when no weeks exist)
            if (teams.length === 0 && data.teams) {
                teams = data.teams;
            }
            teams.filter(t => t.abbrev !== manageState.team).forEach(team => {
                const option = document.createElement('option');
                option.value = team.abbrev;
                option.textContent = `${team.name} (${team.abbrev})`;
                partnerSelect.appendChild(option);
            });
            
            partnerSelect.onchange = () => {
                manageState.tradePartner = partnerSelect.value;
                // Clear selected picks when partner changes
                manageState.tradeReceivePicks = [];
                if (partnerSelect.value) {
                    renderTradePlayers();
                }
                renderTradePicks();
            };
            
            // Clear trade lists initially
            document.getElementById('trade-give-players').innerHTML = '<p class="no-pending-trades">Select trade partner first</p>';
            document.getElementById('trade-receive-players').innerHTML = '<p class="no-pending-trades">Select trade partner first</p>';
            
            // Render picks for current team (give picks always available)
            renderTradePicks();
            
            document.getElementById('trade-submit-btn').onclick = submitTradeProposal;
        }

        function renderTradePlayers() {
            const myTeamData = getTeamData(manageState.team);
            const partnerTeamData = getTeamData(manageState.tradePartner);
            
            if (!myTeamData || !partnerTeamData) return;
            
            // My players to give
            const giveList = document.getElementById('trade-give-players');
            giveList.innerHTML = myTeamData.roster.map(player => `
                <div class="tx-player" data-name="${player.name}">
                    <span class="position-tag">${player.position}</span>
                    <span class="player-name">${player.name}</span>
                    <span class="player-team">${player.nfl_team}</span>
                </div>
            `).join('');
            
            giveList.querySelectorAll('.tx-player').forEach(el => {
                el.onclick = () => toggleTradePlayer('give', el.dataset.name, el);
            });
            
            // Partner players to receive
            const receiveList = document.getElementById('trade-receive-players');
            receiveList.innerHTML = partnerTeamData.roster.map(player => `
                <div class="tx-player" data-name="${player.name}">
                    <span class="position-tag">${player.position}</span>
                    <span class="player-name">${player.name}</span>
                    <span class="player-team">${player.nfl_team}</span>
                </div>
            `).join('');
            
            receiveList.querySelectorAll('.tx-player').forEach(el => {
                el.onclick = () => toggleTradePlayer('receive', el.dataset.name, el);
            });
            
            // Draft picks (simplified - showing years 2026-2028)
            renderTradePicks();
        }

        function toggleTradePlayer(direction, name, el) {
            const list = direction === 'give' ? manageState.tradeGivePlayers : manageState.tradeReceivePlayers;
            const idx = list.indexOf(name);
            const itemId = `player-${direction}-${name}`;
            
            if (idx >= 0) {
                list.splice(idx, 1);
                el.classList.remove('selected');
                // Remove condition if item was deselected
                delete manageState.tradeConditions[itemId];
            } else {
                list.push(name);
                el.classList.add('selected');
            }
            renderTradeConditions();
        }

        function renderTradePicks() {
            const givePicksList = document.getElementById('trade-give-picks');
            const receivePicksList = document.getElementById('trade-receive-picks');
            
            if (!givePicksList || !receivePicksList) return;
            
            // Get picks the current team owns from draft_picks data
            const myPicks = manageState.team ? getOwnedPicks(manageState.team) : [];
            
            if (myPicks.length === 0) {
                givePicksList.innerHTML = manageState.team 
                    ? '<div class="tx-empty">No tradeable picks</div>'
                    : '<div class="tx-empty">Login to see your picks</div>';
            } else {
                givePicksList.innerHTML = myPicks.map(pick => {
                    const conditionHtml = pick.condition ? `<span class="tx-pick-condition" title="${pick.condition.replace(/"/g, '&quot;')}">âš¡ ${pick.condition}</span>` : '';
                    return `
                    <div class="tx-pick" data-pick="${pick.id}" data-condition="${pick.condition || ''}">
                        <span class="tx-pick-label">${pick.label}</span>
                        ${conditionHtml}
                    </div>`;
                }).join('');
            
            givePicksList.querySelectorAll('.tx-pick').forEach(el => {
                el.onclick = () => toggleTradePick('give', el.dataset.pick, el);
            });
            }
            
            // Partner picks to receive - only show if partner is selected
            if (manageState.tradePartner) {
                const partnerPicks = getOwnedPicks(manageState.tradePartner);
                
                if (partnerPicks.length === 0) {
                    receivePicksList.innerHTML = '<div class="tx-empty">Partner has no tradeable picks</div>';
                } else {
                    receivePicksList.innerHTML = partnerPicks.map(pick => {
                        const conditionHtml = pick.condition ? `<span class="tx-pick-condition" title="${pick.condition.replace(/"/g, '&quot;')}">âš¡ ${pick.condition}</span>` : '';
                        return `
                        <div class="tx-pick" data-pick="${pick.id}" data-condition="${pick.condition || ''}">
                            <span class="tx-pick-label">${pick.label}</span>
                            ${conditionHtml}
                        </div>`;
                    }).join('');
            
            receivePicksList.querySelectorAll('.tx-pick').forEach(el => {
                el.onclick = () => toggleTradePick('receive', el.dataset.pick, el);
            });
                }
            } else {
                receivePicksList.innerHTML = '<div class="tx-empty">Select a trade partner first</div>';
            }
        }
        
        function getOwnedPicks(teamCode) {
            // Get picks that a team currently owns from draft_picks data
            // New format: flat array of picks with original_team, current_owner, etc.
            const picks = [];
            const allPicks = data.draft_picks || [];
            
            if (!Array.isArray(allPicks)) return picks;
            
            // Define pick types with their display info and sort order
            const pickTypeInfo = {
                'offseason': { prefix: '', sortOrder: 0 },
                'offseason_taxi': { prefix: 'Taxi ', sortOrder: 1 },
                'waiver': { prefix: 'Waiver ', sortOrder: 2 },
                'waiver_taxi': { prefix: 'Waiver Taxi ', sortOrder: 3 }
            };
            
            for (const pick of allPicks) {
                if (pick.current_owner !== teamCode) continue;
                
                const typeInfo = pickTypeInfo[pick.draft_type] || { prefix: '', sortOrder: 9 };
                const fromLabel = pick.original_team !== teamCode ? ` (${pick.original_team})` : '';
                const idSuffix = pick.draft_type !== 'offseason' ? `-${pick.draft_type}` : '';
                
                // Calculate "via" from previous_owners
                const prevOwners = pick.previous_owners || [];
                const lastPrevOwner = prevOwners.length > 0 ? prevOwners[prevOwners.length - 1] : null;
                const viaLabel = (lastPrevOwner && lastPrevOwner !== pick.original_team) ? ` via ${lastPrevOwner}` : '';
                
                picks.push({
                    id: `${pick.year}${idSuffix}-R${pick.round}-${pick.original_team}`,
                    label: `${pick.year} ${typeInfo.prefix}R${pick.round}${fromLabel}${viaLabel}`,
                    year: parseInt(pick.year),
                    round: pick.round,
                    original_team: pick.original_team,
                    draft_type: pick.draft_type,
                    typeOrder: typeInfo.sortOrder,
                    condition: pick.condition || null
                });
            }
            
            // Sort by year, then by type (regular before taxi before waiver), then by round
            picks.sort((a, b) => a.year - b.year || a.typeOrder - b.typeOrder || a.round - b.round);
            
            return picks;
        }

        function toggleTradePick(direction, pick, el) {
            const list = direction === 'give' ? manageState.tradeGivePicks : manageState.tradeReceivePicks;
            const idx = list.indexOf(pick);
            const itemId = `pick-${direction}-${pick}`;
            
            if (idx >= 0) {
                list.splice(idx, 1);
                el.classList.remove('selected');
                // Remove condition if item was deselected
                delete manageState.tradeConditions[itemId];
            } else {
                list.push(pick);
                el.classList.add('selected');
            }
            renderTradeConditions();
        }

        function renderTradeConditions() {
            const section = document.getElementById('trade-conditions-section');
            const list = document.getElementById('trade-conditions-list');
            
            if (!section || !list) return;
            
            // Collect all selected items
            const items = [];
            
            // Players you're giving
            for (const name of manageState.tradeGivePlayers) {
                items.push({
                    id: `player-give-${name}`,
                    label: name,
                    type: 'Player (giving)',
                    direction: 'give'
                });
            }
            
            // Players you're receiving
            for (const name of manageState.tradeReceivePlayers) {
                items.push({
                    id: `player-receive-${name}`,
                    label: name,
                    type: 'Player (receiving)',
                    direction: 'receive'
                });
            }
            
            // Picks you're giving
            for (const pickId of manageState.tradeGivePicks) {
                items.push({
                    id: `pick-give-${pickId}`,
                    label: pickId.replace(/-/g, ' '),
                    type: 'Pick (giving)',
                    direction: 'give'
                });
            }
            
            // Picks you're receiving
            for (const pickId of manageState.tradeReceivePicks) {
                items.push({
                    id: `pick-receive-${pickId}`,
                    label: pickId.replace(/-/g, ' '),
                    type: 'Pick (receiving)',
                    direction: 'receive'
                });
            }
            
            // Show/hide section based on whether there are items
            if (items.length === 0) {
                section.style.display = 'none';
                return;
            }
            
            section.style.display = 'block';
            
            // Render condition inputs for each item
            list.innerHTML = items.map(item => {
                const existingCondition = manageState.tradeConditions[item.id] || '';
                return `
                    <div class="trade-condition-item">
                        <div class="trade-condition-label">
                            <span class="item-type">${item.type}</span>
                            ${item.label}
                        </div>
                        <input type="text" 
                            class="trade-condition-input" 
                            data-item-id="${item.id}"
                            value="${existingCondition.replace(/"/g, '&quot;')}"
                            placeholder="Add condition (optional)..."
                            maxlength="200">
                    </div>
                `;
            }).join('');
            
            // Add input listeners
            list.querySelectorAll('.trade-condition-input').forEach(input => {
                input.oninput = (e) => {
                    const itemId = e.target.dataset.itemId;
                    const value = e.target.value.trim();
                    if (value) {
                        manageState.tradeConditions[itemId] = value;
                    } else {
                        delete manageState.tradeConditions[itemId];
                    }
                };
            });
        }

        async function submitTradeProposal() {
            const statusEl = document.getElementById('trade-status');
            
            if (!manageState.tradePartner) {
                statusEl.className = 'submit-status error';
                statusEl.textContent = 'Please select a trade partner';
                return;
            }
            
            if (manageState.tradeGivePlayers.length === 0 && 
                manageState.tradeGivePicks.length === 0 &&
                manageState.tradeReceivePlayers.length === 0 &&
                manageState.tradeReceivePicks.length === 0) {
                statusEl.className = 'submit-status error';
                statusEl.textContent = 'Trade must include at least one player or pick';
                return;
            }
            
            statusEl.className = 'submit-status loading';
            statusEl.textContent = 'Proposing trade...';
            
            // Get optional comment
            const commentEl = document.getElementById('trade-comment');
            const comment = commentEl ? commentEl.value.trim() : '';
            
            try {
                const response = await fetch(MANAGE_CONFIG.apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        action: 'propose_trade',
                        team: manageState.team,
                        password: manageState.password,
                        trade_partner: manageState.tradePartner,
                        give_players: manageState.tradeGivePlayers,
                        give_picks: manageState.tradeGivePicks,
                        receive_players: manageState.tradeReceivePlayers,
                        receive_picks: manageState.tradeReceivePicks,
                        conditions: manageState.tradeConditions,
                        current_week: data.current_week,
                        comment: comment,
                        submitted_at: new Date().toISOString()
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    statusEl.className = 'submit-status success';
                    statusEl.textContent = result.message;
                    // Reset trade selections
                    manageState.tradeGivePlayers = [];
                    manageState.tradeGivePicks = [];
                    manageState.tradeReceivePlayers = [];
                    manageState.tradeReceivePicks = [];
                    manageState.tradeConditions = {};
                    setTimeout(() => loadData(), 2000);
                } else {
                    statusEl.className = 'submit-status error';
                    statusEl.textContent = result.error;
                }
            } catch (e) {
                statusEl.className = 'submit-status error';
                statusEl.textContent = 'Network error - please try again';
            }
        }

        function renderPendingTrades() {
            const container = document.getElementById('pending-trades');
            const pendingTrades = data.pending_trades || [];
            
            // Filter trades: only pending status, involving current team
            const relevantTrades = pendingTrades.filter(t => 
                t.status === 'pending' && 
                (t.proposer === manageState.team || t.partner === manageState.team)
            );
            
            if (relevantTrades.length === 0) {
                container.innerHTML = '<p class="no-pending-trades">No pending trades</p>';
                return;
            }
            
            container.innerHTML = relevantTrades.map(trade => {
                const isProposer = trade.proposer === manageState.team;
                const otherTeam = isProposer ? trade.partner : trade.proposer;
                const otherTeamData = getTeamData(otherTeam);
                const otherTeamName = otherTeamData ? otherTeamData.name : otherTeam;
                const conditions = trade.conditions || {};
                
                // Helper to format item with condition
                const formatItem = (item, type, direction) => {
                    const conditionKey = `${type}-${direction}-${item}`;
                    const condition = conditions[conditionKey];
                    if (condition) {
                        return `<li>${item} <span class="pending-trade-condition">âš¡ ${condition}</span></li>`;
                    }
                    return `<li>${item}</li>`;
                };
                
                return `
                    <div class="pending-trade-card" data-trade-id="${trade.id}">
                        <div class="pending-trade-header">
                            <span class="pending-trade-teams">
                                ${isProposer ? 'You â†’ ' + otherTeamName : otherTeamName + ' â†’ You'}
                            </span>
                            <span class="pending-status-badge ${trade.status}">${trade.status.toUpperCase()}</span>
                        </div>
                        <div class="pending-trade-details">
                            <div class="pending-trade-side">
                                <h5>${isProposer ? 'You give' : 'You receive'}</h5>
                                <ul>
                                    ${trade.proposer_gives.players.map(p => formatItem(p, 'player', 'give')).join('')}
                                    ${trade.proposer_gives.picks.map(p => formatItem(p, 'pick', 'give')).join('')}
                                    ${trade.proposer_gives.players.length === 0 && trade.proposer_gives.picks.length === 0 ? '<li>(nothing)</li>' : ''}
                                </ul>
                            </div>
                            <div class="pending-trade-side">
                                <h5>${isProposer ? 'You receive' : 'You give'}</h5>
                                <ul>
                                    ${trade.proposer_receives.players.map(p => formatItem(p, 'player', 'receive')).join('')}
                                    ${trade.proposer_receives.picks.map(p => formatItem(p, 'pick', 'receive')).join('')}
                                    ${trade.proposer_receives.players.length === 0 && trade.proposer_receives.picks.length === 0 ? '<li>(nothing)</li>' : ''}
                                </ul>
                            </div>
                        </div>
                        ${trade.status === 'pending' && !isProposer ? `
                            <div class="pending-trade-actions">
                                <button class="lineup-btn accept-btn" onclick="respondToTrade('${trade.id}', true)">Accept</button>
                                <button class="lineup-btn reject-btn" onclick="respondToTrade('${trade.id}', false)">Reject</button>
                            </div>
                        ` : ''}
                        ${trade.status === 'pending' && isProposer ? `
                            <div class="pending-trade-actions">
                                <span style="color: var(--text-secondary);">Waiting for ${otherTeamName} to respond</span>
                                <button class="lineup-btn reject-btn" onclick="cancelTrade('${trade.id}')">Cancel</button>
                            </div>
                        ` : ''}
                    </div>
                `;
            }).join('');
        }

        async function respondToTrade(tradeId, accept) {
            const statusEl = document.getElementById('pending-status');
            statusEl.className = 'submit-status loading';
            statusEl.textContent = accept ? 'Accepting trade...' : 'Rejecting trade...';
            
            try {
                const response = await fetch(MANAGE_CONFIG.apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        action: 'respond_trade',
                        team: manageState.team,
                        password: manageState.password,
                        trade_id: tradeId,
                        accept: accept
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    statusEl.className = 'submit-status success';
                    statusEl.textContent = result.message;
                    setTimeout(() => loadData(), 2000);
                } else {
                    statusEl.className = 'submit-status error';
                    statusEl.textContent = result.error;
                }
            } catch (e) {
                statusEl.className = 'submit-status error';
                statusEl.textContent = 'Network error - please try again';
            }
        }

        async function cancelTrade(tradeId) {
            const statusEl = document.getElementById('pending-status');
            statusEl.className = 'submit-status loading';
            statusEl.textContent = 'Cancelling trade...';
            
            try {
                const response = await fetch(MANAGE_CONFIG.apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        action: 'cancel_trade',
                        team: manageState.team,
                        password: manageState.password,
                        trade_id: tradeId
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    statusEl.className = 'submit-status success';
                    statusEl.textContent = result.message;
                    setTimeout(() => loadData(), 2000);
                } else {
                    statusEl.className = 'submit-status error';
                    statusEl.textContent = result.error;
                }
            } catch (e) {
                statusEl.className = 'submit-status error';
                statusEl.textContent = 'Network error - please try again';
            }
        }

        function renderTradeBlockTab() {
            if (!manageState.team) return;
            
            const tradeBlocks = data.trade_blocks || {};
            const teamBlock = tradeBlocks[manageState.team] || {};
            
            // Populate seeking checkboxes
            const seekingContainer = document.getElementById('seeking-positions');
            seekingContainer.querySelectorAll('input[type="checkbox"]').forEach(cb => {
                cb.checked = (teamBlock.seeking || []).includes(cb.value);
                cb.parentElement.classList.toggle('selected', cb.checked);
                cb.onchange = () => cb.parentElement.classList.toggle('selected', cb.checked);
            });
            
            // Populate trading away checkboxes
            const tradingContainer = document.getElementById('trading-positions');
            tradingContainer.querySelectorAll('input[type="checkbox"]').forEach(cb => {
                cb.checked = (teamBlock.trading_away || []).includes(cb.value);
                cb.parentElement.classList.toggle('selected', cb.checked);
                cb.onchange = () => cb.parentElement.classList.toggle('selected', cb.checked);
            });
            
            // Populate player selection
            const playersContainer = document.getElementById('available-players');
            const teamData = getTeamData(manageState.team);
            
            if (teamData && teamData.roster) {
                const availablePlayers = teamBlock.players_available || [];
                playersContainer.innerHTML = teamData.roster.map(player => `
                    <label class="trade-block-player-item ${availablePlayers.includes(player.name) ? 'selected' : ''}">
                        <input type="checkbox" value="${player.name}" ${availablePlayers.includes(player.name) ? 'checked' : ''}>
                        <span class="trade-block-player-pos">${player.position}</span>
                        <span class="trade-block-player-name">${player.name}</span>
                    </label>
                `).join('');
                
                // Add listeners
                playersContainer.querySelectorAll('input[type="checkbox"]').forEach(cb => {
                    cb.onchange = () => cb.parentElement.classList.toggle('selected', cb.checked);
                });
            } else {
                playersContainer.innerHTML = '<p style="color: var(--text-muted);">No roster data available</p>';
            }
            
            // Populate notes
            document.getElementById('tradeblock-notes').value = teamBlock.notes || '';
            
            // Set up submit button
            document.getElementById('tradeblock-submit-btn').onclick = saveTradeBlock;
        }

        async function saveTradeBlock() {
            const statusEl = document.getElementById('tradeblock-status');
            const submitBtn = document.getElementById('tradeblock-submit-btn');
            
            // Gather data
            const seeking = [];
            document.querySelectorAll('#seeking-positions input:checked').forEach(cb => {
                seeking.push(cb.value);
            });
            
            const tradingAway = [];
            document.querySelectorAll('#trading-positions input:checked').forEach(cb => {
                tradingAway.push(cb.value);
            });
            
            const playersAvailable = [];
            document.querySelectorAll('#available-players input:checked').forEach(cb => {
                playersAvailable.push(cb.value);
            });
            
            const notes = document.getElementById('tradeblock-notes').value.trim();
            
            // Show loading state
            statusEl.className = 'submit-status loading';
            statusEl.textContent = 'Saving trade block...';
            submitBtn.disabled = true;
            
            try {
                const response = await fetch(MANAGE_CONFIG.apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        action: 'save_tradeblock',
                        team: manageState.team,
                        password: manageState.password,
                        seeking: seeking,
                        trading_away: tradingAway,
                        players_available: playersAvailable,
                        notes: notes
                    })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    statusEl.className = 'submit-status success';
                    statusEl.textContent = 'Trade block saved successfully!';
                    // Reload data to update the teams view
                    setTimeout(() => loadData(), 1500);
                } else {
                    statusEl.className = 'submit-status error';
                    statusEl.textContent = result.error || 'Failed to save trade block';
                }
            } catch (e) {
                statusEl.className = 'submit-status error';
                statusEl.textContent = 'Network error - please try again';
            }
            
            submitBtn.disabled = false;
        }

        // Auto-refresh every 5 minutes during game windows
        function checkRefresh() {
            const now = new Date();
            const day = now.getDay(); // 0=Sun, 4=Thu, 1=Mon
            const hour = now.getHours();
            
            let inGameWindow = false;
            if (day === 4 && hour >= 20) inGameWindow = true; // Thursday night
            if (day === 0 && hour >= 12) inGameWindow = true; // Sunday afternoon
            if (day === 1 && hour >= 20) inGameWindow = true; // Monday night
            
            if (inGameWindow) {
                setTimeout(() => {
                    loadData();
                    checkRefresh();
                }, 5 * 60 * 1000); // 5 minutes
            } else {
                setTimeout(checkRefresh, 30 * 60 * 1000); // Check again in 30 min
            }
        }

        loadData();
        checkRefresh();
    </script>
</body>
</html>

